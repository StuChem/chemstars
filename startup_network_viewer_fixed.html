<!DOCTYPE html>
<html>
<head>
    <title>Startup Network Viewer</title>
    <meta charset="utf-8">
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            font-family: Arial, sans-serif; 
            background-color: #f5f5f5;
        }
        
        #header {
            background-color: #2c3e50;
            color: white;
            padding: 15px 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        #header h1 {
            margin: 0;
            font-size: 24px;
        }
        
        #file-controls {
            background-color: white;
            padding: 15px 20px;
            border-bottom: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        #file-input {
            margin-right: 15px;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        
        #load-button {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        
        #load-button:hover {
            background-color: #2980b9;
        }
        
        #load-button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        
        #controls {
            position: absolute;
            top: 120px;
            left: 20px;
            z-index: 1000;
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-width: 200px;
        }
        
        #controls h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #2c3e50;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #34495e;
        }
        
        button {
            background-color: #34495e;
            color: white;
            border: none;
            padding: 8px 15px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }
        
        button:hover {
            background-color: #2c3e50;
        }
        
        .filter-btn {
            font-size: 11px;
            padding: 6px 10px;
            margin: 1px;
        }
        
        .filter-btn.active {
            background-color: #3498db;
        }
        
        .filter-btn.active:hover {
            background-color: #2980b9;
        }
        
        .filter-mode-btn {
            background-color: #e74c3c;
            font-size: 10px;
            padding: 4px 8px;
            margin-right: 5px;
        }
        
        .filter-mode-btn.and-mode {
            background-color: #27ae60;
        }
        
        .clear-btn {
            background-color: #95a5a6;
            font-size: 10px;
            padding: 4px 8px;
        }
        
        .filter-section {
            margin-bottom: 8px;
            padding: 5px;
            background-color: #f8f9fa;
            border-radius: 3px;
            border: 1px solid #e9ecef;
        }
        
        .filter-checkboxes {
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        
        .checkbox-label {
            font-size: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 2px;
            font-weight: normal;
        }
        
        .checkbox-label input[type="checkbox"] {
            margin: 0;
            transform: scale(0.8);
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        #sigma-container {
            width: 100%;
            height: calc(100vh - 120px);
            background-color: #ffffff;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #7f8c8d;
            font-size: 18px;
            z-index: 500;
        }
        
        #stats {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: white;
            padding: 10px 15px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            font-size: 12px;
            color: #7f8c8d;
        }
        
        .hidden {
            display: none;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>üåê Startup Network Viewer</h1>
    </div>
    
    <div id="file-controls">
        <input type="file" id="file-input" accept=".gexf" />
        <button id="load-button" onclick="loadGraphFile()">Load GEXF File</button>
        <span id="file-status" style="margin-left: 15px; color: #7f8c8d;"></span>
    </div>
    
    <div id="loading" class="hidden">
        <div>üìä Loading your network graph...</div>
        <div style="margin-top: 10px; font-size: 14px;">Please wait while we process the data</div>
    </div>
    
    <div id="controls" class="hidden">
        <h3>üéõÔ∏è Controls</h3>
        
        <div class="control-group">
            <label>View Controls:</label>
            <button onclick="zoomIn()">üîç Zoom In</button>
            <button onclick="zoomOut()">üîç Zoom Out</button>
            <button onclick="resetView()">üéØ Reset View</button>
        </div>
        
        <div class="control-group">
            <label>Node Size:</label>
            <input type="range" id="node-size" min="1" max="10" value="3" oninput="updateNodeSize(this.value)">
            <span id="node-size-value">3</span>
        </div>
        
        <div class="control-group">
            <label>Edge Thickness:</label>
            <input type="range" id="edge-size" min="0.5" max="3" step="0.5" value="1" oninput="updateEdgeSize(this.value)">
            <span id="edge-size-value">1</span>
        </div>
        
        <div class="control-group">
            <label>Display:</label>
            <button onclick="toggleLabels()" id="labels-toggle">üè∑Ô∏è Toggle Labels</button>
            <button onclick="toggleHoverLabels()" id="hover-labels-toggle">üñ±Ô∏è Toggle Hover Labels</button>
        </div>
        
        <div class="control-group">
            <label>üîç Advanced Filters:</label>
            <div style="margin-bottom: 8px;">
                <button onclick="toggleFilterMode()" id="filter-mode-btn" class="filter-mode-btn">Mode: OR</button>
                <button onclick="clearAllFilters()" class="clear-btn">Clear All</button>
            </div>
            
            <div class="filter-section">
                <label style="font-size: 11px; margin-bottom: 3px;">Connection Types:</label>
                <div class="filter-checkboxes">
                    <label class="checkbox-label">
                        <input type="checkbox" id="filter-competency" onchange="updateFilters()"> Competencies
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="filter-impact" onchange="updateFilters()"> Impact
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="filter-city" onchange="updateFilters()"> Cities
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="filter-country" onchange="updateFilters()"> Countries
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="filter-target_market" onchange="updateFilters()"> Markets
                    </label>
                </div>
            </div>
            
            <div class="filter-section">
                <label style="font-size: 11px; margin-bottom: 3px;">Edge Weight:</label>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <span style="font-size: 10px;">Min:</span>
                    <input type="range" id="weight-min" min="1" max="10" value="1" style="width: 60px;" oninput="updateFilters()">
                    <span id="weight-min-value" style="font-size: 10px; width: 15px;">1</span>
                    <span style="font-size: 10px;">Max:</span>
                    <input type="range" id="weight-max" min="1" max="10" value="10" style="width: 60px;" oninput="updateFilters()">
                    <span id="weight-max-value" style="font-size: 10px; width: 15px;">10</span>
                </div>
            </div>
            
            <div class="filter-section">
                <label style="font-size: 11px; margin-bottom: 3px;">Node Filters:</label>
                <div class="filter-checkboxes">
                    <label class="checkbox-label">
                        <input type="checkbox" id="hide-isolated" onchange="updateFilters()"> Hide Isolated Nodes
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="show-hubs" onchange="updateFilters()"> Show Only Hubs (5+ connections)
                    </label>
                </div>
            </div>
            
            <div class="filter-section">
                <label for="search-nodes" style="font-size: 11px; margin-bottom: 3px;">Search Nodes:</label>
                <input type="text" id="search-nodes" placeholder="Type to search..." style="width: 100%; font-size: 11px; padding: 3px;" oninput="updateFilters()">
            </div>
        </div>
    </div>
    
    <div id="sigma-container"></div>
    
    <div id="stats" class="hidden">
        <div id="graph-stats"></div>
    </div>

    <!-- Include sigma.js and graphology from CDN -->
    <script src="https://unpkg.com/graphology@0.25.4/dist/graphology.umd.min.js"></script>
    <script src="https://unpkg.com/sigma@2.4.0/build/sigma.min.js"></script>
    
    <script>
        let sigmaInstance = null;
        let graph = null;
        let showLabels = true;
        let showHoverLabels = true;
        let currentFilter = 'all';
        let originalEdgeColors = new Map();
        let filterMode = 'OR'; // 'OR' or 'AND'
        let activeFilters = {
            types: [],
            weightMin: 1,
            weightMax: 10,
            hideIsolated: false,
            showHubs: false,
            searchText: ''
        };
        
        function setStatus(message, isError = false) {
            const statusEl = document.getElementById('file-status');
            statusEl.textContent = message;
            statusEl.style.color = isError ? '#e74c3c' : '#27ae60';
        }
        
        function showLoading() {
            document.getElementById('loading').classList.remove('hidden');
        }
        
        function hideLoading() {
            document.getElementById('loading').classList.add('hidden');
        }
        
        function showControls() {
            document.getElementById('controls').classList.remove('hidden');
            document.getElementById('stats').classList.remove('hidden');
        }
        
        function updateStats() {
            if (activeFilters.types.length > 0 || activeFilters.searchText || activeFilters.hideIsolated || activeFilters.showHubs) {
                updateAdvancedStats();
            } else {
                if (!graph) return;
                
                const nodeCount = graph.order;
                const edgeCount = graph.size;
                const statsEl = document.getElementById('graph-stats');
                
                statsEl.innerHTML = `
                    <strong>Network Stats:</strong><br>
                    üìç Nodes: ${nodeCount}<br>
                    üîó Edges: ${edgeCount}<br>
                    üìä Density: ${(edgeCount / (nodeCount * (nodeCount - 1) / 2) * 100).toFixed(2)}%
                `;
            }
        }
        
        // Manual GEXF parser function
        function parseGexfToGraph(graph, gexfString) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(gexfString, 'text/xml');
            
            // Check for parsing errors
            const parserError = xmlDoc.querySelector('parsererror');
            if (parserError) {
                throw new Error('XML parsing failed: ' + parserError.textContent);
            }
            
            // Parse nodes
            const nodes = xmlDoc.querySelectorAll('node');
            console.log(`Found ${nodes.length} nodes in GEXF file`);
            
            nodes.forEach(node => {
                const id = node.getAttribute('id');
                const label = node.getAttribute('label') || id;
                
                // Get node attributes
                const attributes = { label: label };
                
                // Parse attvalues (custom attributes)
                const attvalues = node.querySelectorAll('attvalue');
                attvalues.forEach(att => {
                    const key = att.getAttribute('for') || att.getAttribute('id');
                    const value = att.getAttribute('value');
                    if (key && value !== null) {
                        attributes[key] = value;
                    }
                });
                
                // Get position if available (with namespace handling)
                let x = Math.random() * 100;
                let y = Math.random() * 100;
                
                const vizPosition = node.querySelector('position') || 
                                  node.querySelector('[*|position]') ||
                                  Array.from(node.children).find(child => 
                                      child.localName === 'position' || 
                                      child.tagName.includes('position')
                                  );
                
                if (vizPosition) {
                    x = parseFloat(vizPosition.getAttribute('x')) || x;
                    y = parseFloat(vizPosition.getAttribute('y')) || y;
                }
                
                attributes.x = x;
                attributes.y = y;
                
                // Get color if available
                let color = '#666';
                const vizColor = node.querySelector('color') || 
                               node.querySelector('[*|color]') ||
                               Array.from(node.children).find(child => 
                                   child.localName === 'color' || 
                                   child.tagName.includes('color')
                               );
                
                if (vizColor) {
                    const r = vizColor.getAttribute('r');
                    const g = vizColor.getAttribute('g');
                    const b = vizColor.getAttribute('b');
                    if (r !== null && g !== null && b !== null) {
                        color = `rgb(${r},${g},${b})`;
                    }
                }
                
                // Get size - make all nodes uniform and small
                let size = 3; // Small uniform size
                
                attributes.color = color;
                attributes.size = size;
                
                graph.addNode(id, attributes);
            });
            
            // Parse edges
            const edges = xmlDoc.querySelectorAll('edge');
            console.log(`Found ${edges.length} edges in GEXF file`);
            
            edges.forEach(edge => {
                const source = edge.getAttribute('source');
                const target = edge.getAttribute('target');
                const label = edge.getAttribute('label') || '';
                const weight = parseFloat(edge.getAttribute('weight')) || 1;
                
                // Get edge attributes
                const attributes = { 
                    label: label,
                    weight: weight,
                    Weight: weight // Also store with capital W for compatibility
                };
                
                // Parse attvalues (custom attributes)
                const attvalues = edge.querySelectorAll('attvalue');
                attvalues.forEach(att => {
                    const key = att.getAttribute('for') || att.getAttribute('id');
                    const value = att.getAttribute('value');
                    if (key && value !== null) {
                        attributes[key] = value;
                        
                        // Convert boolean flags from string to boolean
                        if (key.startsWith('is_') && (value === '1' || value === '0')) {
                            attributes[key] = value === '1';
                        }
                    }
                });
                
                // Use labeldetailed as the primary label for display
                if (attributes.labeldetailed) {
                    attributes.label = attributes.labeldetailed;
                }
                
                // Get edge color if available
                let edgeColor = '#ccc';
                const vizColor = edge.querySelector('color') || 
                               edge.querySelector('[*|color]') ||
                               Array.from(edge.children).find(child => 
                                   child.localName === 'color' || 
                                   child.tagName.includes('color')
                               );
                
                if (vizColor) {
                    const r = vizColor.getAttribute('r');
                    const g = vizColor.getAttribute('g');
                    const b = vizColor.getAttribute('b');
                    if (r !== null && g !== null && b !== null) {
                        edgeColor = `rgb(${r},${g},${b})`;
                    }
                }
                attributes.color = edgeColor;
                
                // Add edge if both nodes exist
                if (source && target && graph.hasNode(source) && graph.hasNode(target)) {
                    try {
                        graph.addEdge(source, target, attributes);
                    } catch (e) {
                        // Edge might already exist in multigraph, try with unique key
                        const edgeKey = `${source}-${target}-${Math.random()}`;
                        graph.addEdgeWithKey(edgeKey, source, target, attributes);
                    }
                } else {
                    console.warn(`Skipping edge ${source} -> ${target} (missing nodes)`);
                }
            });
        }
        
        async function loadGraphFile() {
            const fileInput = document.getElementById('file-input');
            const file = fileInput.files[0];
            
            if (!file) {
                setStatus('Please select a GEXF file first', true);
                return;
            }
            
            if (!file.name.toLowerCase().endsWith('.gexf')) {
                setStatus('Please select a valid GEXF file', true);
                return;
            }
            
            showLoading();
            setStatus('Loading...');
            
            try {
                // Read the file
                const text = await file.text();
                console.log('GEXF file loaded, length:', text.length);
                
                // Create a new graph
                graph = new graphology.Graph();
                
                // Parse the GEXF data using our custom parser
                parseGexfToGraph(graph, text);
                
                console.log(`Graph loaded: ${graph.order} nodes, ${graph.size} edges`);
                
                // Clear any existing sigma instance
                if (sigmaInstance) {
                    sigmaInstance.kill();
                }
                
                // Style the nodes and edges
                styleGraph();
                
                // Create new sigma instance with edge events enabled
                sigmaInstance = new Sigma(graph, document.getElementById('sigma-container'), {
                    renderLabels: showLabels,
                    renderEdgeLabels: false, // Never show edge labels by default
                    defaultNodeColor: '#666',
                    defaultEdgeColor: '#ccc',
                    labelFont: 'Arial',
                    labelSize: 12,
                    labelWeight: 'normal',
                    minCameraRatio: 0.1,
                    maxCameraRatio: 10,
                    // Enable edge interaction events
                    enableEdgeHoverEvents: true,
                    enableEdgeClickEvents: true
                });
                
                // Add hover interactions for labels
                setupHoverInteractions();
                
                // Add click handlers for nodes
                sigmaInstance.on('clickNode', (event) => {
                    const nodeData = graph.getNodeAttributes(event.node);
                    console.log('Clicked node:', event.node, nodeData);
                });
                
                hideLoading();
                showControls();
                updateStats();
                setStatus(`Successfully loaded: ${file.name}`);
                
            } catch (error) {
                hideLoading();
                console.error('Error loading GEXF file:', error);
                setStatus(`Error: ${error.message}`, true);
            }
        }
        
        function styleGraph() {
            if (!graph) return;
            
            // Make all nodes uniform small size with their original colors
            graph.forEachNode((node, attributes) => {
                let color = attributes.color || '#95a5a6'; // use existing color or default gray
                let size = 3; // Uniform small size for all nodes
                
                graph.setNodeAttribute(node, 'color', color);
                graph.setNodeAttribute(node, 'size', size);
            });
            
            // Style edges based on weight and store original colors and sizes
            graph.forEachEdge((edge, attributes) => {
                const weight = attributes.Weight || attributes.weight || 1;
                const thickness = Math.max(0.5, Math.min(3, weight * 0.5));
                
                graph.setEdgeAttribute(edge, 'size', thickness);
                if (!attributes.color) {
                    graph.setEdgeAttribute(edge, 'color', '#bdc3c7');
                }
                
                // Store original color and size for hover interactions
                originalEdgeColors.set(edge, attributes.color || '#bdc3c7');
                graph.setEdgeAttribute(edge, 'originalSize', thickness);
            });
        }
        
        // Remove the old setEdgeTypeFlags function since flags are now set directly from attvalues
        
        function setupHoverInteractions() {
            if (!sigmaInstance) return;
            
            let hoveredNode = null;
            let hoveredEdge = null;
            
            // Node hover events
            sigmaInstance.on('enterNode', (event) => {
                if (!showHoverLabels) return;
                
                hoveredNode = event.node;
                const nodeAttributes = graph.getNodeAttributes(event.node);
                
                // Show tooltip
                showHoverTooltip(event.event.x, event.event.y, {
                    title: nodeAttributes.label || event.node,
                    type: 'node',
                    attributes: nodeAttributes
                });
                
                // Highlight connected edges
                graph.forEachEdge((edge, attributes) => {
                    const [source, target] = graph.extremities(edge);
                    if (source === event.node || target === event.node) {
                        const originalSize = attributes.originalSize || attributes.size || 1;
                        graph.setEdgeAttribute(edge, 'color', '#ff6b6b');
                        graph.setEdgeAttribute(edge, 'size', originalSize * 2);
                    }
                });
                
                sigmaInstance.refresh();
            });
            
            sigmaInstance.on('leaveNode', (event) => {
                if (hoveredNode === event.node) {
                    hoveredNode = null;
                    hideHoverTooltip();
                    
                    // Reset edge colors
                    graph.forEachEdge((edge, attributes) => {
                        const originalColor = originalEdgeColors.get(edge) || '#bdc3c7';
                        const originalSize = attributes.originalSize || 1;
                        graph.setEdgeAttribute(edge, 'color', originalColor);
                        graph.setEdgeAttribute(edge, 'size', originalSize);
                    });
                    
                    sigmaInstance.refresh();
                }
            });
            
            // Edge hover events (now properly enabled)
            sigmaInstance.on('enterEdge', (event) => {
                if (!showHoverLabels) return;
                
                hoveredEdge = event.edge;
                const edgeAttributes = graph.getEdgeAttributes(event.edge);
                const [source, target] = graph.extremities(event.edge);
                
                // Highlight the edge
                const originalSize = edgeAttributes.originalSize || edgeAttributes.size || 1;
                graph.setEdgeAttribute(event.edge, 'color', '#ff6b6b');
                graph.setEdgeAttribute(event.edge, 'size', originalSize * 2);
                sigmaInstance.refresh();
                
                // Show tooltip with labeldetailed
                showHoverTooltip(event.event.x, event.event.y, {
                    title: edgeAttributes.labeldetailed || edgeAttributes.label || `${source} ‚Üí ${target}`,
                    type: 'edge',
                    attributes: edgeAttributes,
                    source: source,
                    target: target
                });
            });
            
            sigmaInstance.on('leaveEdge', (event) => {
                if (hoveredEdge === event.edge) {
                    hoveredEdge = null;
                    hideHoverTooltip();
                    
                    // Reset edge color and size
                    const edgeAttributes = graph.getEdgeAttributes(event.edge);
                    const originalSize = edgeAttributes.originalSize || 1;
                    graph.setEdgeAttribute(event.edge, 'color', originalEdgeColors.get(event.edge) || '#bdc3c7');
                    graph.setEdgeAttribute(event.edge, 'size', originalSize);
                    sigmaInstance.refresh();
                }
            });
        }
        
        function showHoverTooltip(x, y, data) {
            let tooltip = document.getElementById('hover-tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'hover-tooltip';
                tooltip.style.position = 'absolute';
                tooltip.style.background = 'rgba(0,0,0,0.8)';
                tooltip.style.color = 'white';
                tooltip.style.padding = '8px 12px';
                tooltip.style.borderRadius = '4px';
                tooltip.style.fontSize = '12px';
                tooltip.style.zIndex = '9999';
                tooltip.style.pointerEvents = 'none';
                tooltip.style.maxWidth = '300px';
                tooltip.style.wordWrap = 'break-word';
                document.body.appendChild(tooltip);
            }
            
            let content = `<strong>${data.title}</strong>`;
            if (data.type === 'edge' && data.source && data.target) {
                content += `<br><small>From: ${data.source}<br>To: ${data.target}</small>`;
                if (data.attributes.weight) {
                    content += `<br><small>Weight: ${data.attributes.weight}</small>`;
                }
            }
            
            tooltip.innerHTML = content;
            tooltip.style.left = (x + 10) + 'px';
            tooltip.style.top = (y - 10) + 'px';
            tooltip.style.display = 'block';
        }
        
        function hideHoverTooltip() {
            const tooltip = document.getElementById('hover-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }
        
        function zoomIn() {
            if (sigmaInstance) {
                const camera = sigmaInstance.getCamera();
                camera.animatedZoom({ duration: 200 });
            }
        }
        
        function zoomOut() {
            if (sigmaInstance) {
                const camera = sigmaInstance.getCamera();
                camera.animatedUnzoom({ duration: 200 });
            }
        }
        
        function resetView() {
            if (sigmaInstance) {
                const camera = sigmaInstance.getCamera();
                camera.animatedReset({ duration: 500 });
            }
        }
        
        function updateNodeSize(value) {
            document.getElementById('node-size-value').textContent = value;
            if (graph && sigmaInstance) {
                // Set uniform size for all nodes
                graph.forEachNode((node) => {
                    graph.setNodeAttribute(node, 'size', parseFloat(value));
                });
                sigmaInstance.refresh();
            }
        }
        
        function updateEdgeSize(value) {
            document.getElementById('edge-size-value').textContent = value;
            if (graph && sigmaInstance) {
                graph.forEachEdge((edge, attributes) => {
                    const weight = attributes.Weight || attributes.weight || 1;
                    const thickness = Math.max(0.5, weight * parseFloat(value) * 0.5);
                    graph.setEdgeAttribute(edge, 'size', thickness);
                    // Update the stored original size
                    graph.setEdgeAttribute(edge, 'originalSize', thickness);
                });
                sigmaInstance.refresh();
            }
        }
        
        function toggleLabels() {
            showLabels = !showLabels;
            if (sigmaInstance) {
                sigmaInstance.setSetting('renderLabels', showLabels);
                sigmaInstance.refresh();
            }
            document.getElementById('labels-toggle').textContent = 
                showLabels ? 'üè∑Ô∏è Hide Labels' : 'üè∑Ô∏è Show Labels';
        }
        
        function toggleHoverLabels() {
            showHoverLabels = !showHoverLabels;
            document.getElementById('hover-labels-toggle').textContent = 
                showHoverLabels ? 'üñ±Ô∏è Hover Labels: ON' : 'üñ±Ô∏è Hover Labels: OFF';
            
            if (!showHoverLabels) {
                hideHoverTooltip();
            }
        }
        
        function toggleFilterMode() {
            filterMode = filterMode === 'OR' ? 'AND' : 'OR';
            const btn = document.getElementById('filter-mode-btn');
            btn.textContent = `Mode: ${filterMode}`;
            btn.className = filterMode === 'AND' ? 'filter-mode-btn and-mode' : 'filter-mode-btn';
            updateFilters();
        }
        
        function clearAllFilters() {
            // Reset all checkboxes
            ['filter-competency', 'filter-impact', 'filter-city', 'filter-country', 'filter-target_market', 
             'hide-isolated', 'show-hubs'].forEach(id => {
                document.getElementById(id).checked = false;
            });
            
            // Reset sliders
            document.getElementById('weight-min').value = 1;
            document.getElementById('weight-max').value = 10;
            document.getElementById('weight-min-value').textContent = 1;
            document.getElementById('weight-max-value').textContent = 10;
            
            // Clear search
            document.getElementById('search-nodes').value = '';
            
            // Reset filter state
            activeFilters = {
                types: [],
                weightMin: 1,
                weightMax: 10,
                hideIsolated: false,
                showHubs: false,
                searchText: ''
            };
            
            updateFilters();
        }
        
        function updateFilters() {
            // Update weight display values
            const weightMin = parseInt(document.getElementById('weight-min').value);
            const weightMax = parseInt(document.getElementById('weight-max').value);
            document.getElementById('weight-min-value').textContent = weightMin;
            document.getElementById('weight-max-value').textContent = weightMax;
            
            // Collect active type filters
            const typeFilters = [];
            ['competency', 'impact', 'city', 'country', 'target_market'].forEach(type => {
                if (document.getElementById(`filter-${type}`).checked) {
                    typeFilters.push(type);
                }
            });
            
            // Update active filters
            activeFilters = {
                types: typeFilters,
                weightMin: weightMin,
                weightMax: weightMax,
                hideIsolated: document.getElementById('hide-isolated').checked,
                showHubs: document.getElementById('show-hubs').checked,
                searchText: document.getElementById('search-nodes').value.toLowerCase().trim()
            };
            
            applyFilters();
        }
        
        function applyFilters() {
            if (!graph || !sigmaInstance) return;
            
            // First, show all nodes and edges
            graph.forEachNode((node) => {
                graph.setNodeAttribute(node, 'hidden', false);
            });
            
            graph.forEachEdge((edge) => {
                graph.setEdgeAttribute(edge, 'hidden', false);
                graph.setEdgeAttribute(edge, 'color', originalEdgeColors.get(edge) || '#bdc3c7');
            });
            
            // Apply edge type filters
            if (activeFilters.types.length > 0) {
                graph.forEachEdge((edge, attributes) => {
                    let shouldShow = false;
                    
                    if (filterMode === 'OR') {
                        // OR logic: edge should be visible if it matches ANY selected type
                        shouldShow = activeFilters.types.some(type => attributes[`is_${type}`] === true);
                    } else {
                        // AND logic: edge should be visible if it matches ALL selected types
                        shouldShow = activeFilters.types.every(type => attributes[`is_${type}`] === true);
                    }
                    
                    graph.setEdgeAttribute(edge, 'hidden', !shouldShow);
                    
                    // Color code by type if visible
                    if (shouldShow && activeFilters.types.length === 1) {
                        const type = activeFilters.types[0];
                        const colors = {
                            'city': '#e74c3c',
                            'country': '#2ecc71',
                            'competency': '#f39c12',
                            'impact': '#9b59b6',
                            'target_market': '#1abc9c'
                        };
                        graph.setEdgeAttribute(edge, 'color', colors[type] || '#3498db');
                    }
                });
            }
            
            // Apply weight filters
            graph.forEachEdge((edge, attributes) => {
                if (!attributes.hidden) {
                    const weight = attributes.Weight || attributes.weight || 1;
                    if (weight < activeFilters.weightMin || weight > activeFilters.weightMax) {
                        graph.setEdgeAttribute(edge, 'hidden', true);
                    }
                }
            });
            
            // Apply node filters
            graph.forEachNode((node, attributes) => {
                let shouldHide = false;
                
                // Search filter
                if (activeFilters.searchText && !attributes.label?.toLowerCase().includes(activeFilters.searchText)) {
                    shouldHide = true;
                }
                
                // Degree-based filters
                const degree = graph.degree(node);
                
                if (activeFilters.hideIsolated && degree === 0) {
                    shouldHide = true;
                }
                
                if (activeFilters.showHubs && degree < 5) {
                    shouldHide = true;
                }
                
                // Hide nodes that have no visible edges (unless showing all)
                if (!shouldHide && activeFilters.types.length > 0) {
                    const hasVisibleEdge = graph.edges(node).some(edge => !graph.getEdgeAttribute(edge, 'hidden'));
                    if (!hasVisibleEdge) {
                        shouldHide = true;
                    }
                }
                
                graph.setNodeAttribute(node, 'hidden', shouldHide);
            });
            
            sigmaInstance.refresh();
            updateAdvancedStats();
        }
        
        function updateAdvancedStats() {
            if (!graph) return;
            
            let visibleNodes = 0;
            let visibleEdges = 0;
            
            graph.forEachNode((node, attributes) => {
                if (!attributes.hidden) visibleNodes++;
            });
            
            graph.forEachEdge((edge, attributes) => {
                if (!attributes.hidden) visibleEdges++;
            });
            
            const totalNodes = graph.order;
            const totalEdges = graph.size;
            
            const statsEl = document.getElementById('graph-stats');
            let filterSummary = [];
            
            if (activeFilters.types.length > 0) {
                filterSummary.push(`${activeFilters.types.join(' ' + filterMode + ' ')}`);
            }
            if (activeFilters.weightMin > 1 || activeFilters.weightMax < 10) {
                filterSummary.push(`Weight: ${activeFilters.weightMin}-${activeFilters.weightMax}`);
            }
            if (activeFilters.hideIsolated) filterSummary.push('No isolated');
            if (activeFilters.showHubs) filterSummary.push('Hubs only');
            if (activeFilters.searchText) filterSummary.push(`"${activeFilters.searchText}"`);
            
            const filterText = filterSummary.length > 0 ? filterSummary.join(', ') : 'None';
            
            statsEl.innerHTML = `
                <strong>Network Stats:</strong><br>
                üìç Nodes: ${visibleNodes}/${totalNodes}<br>
                üîó Edges: ${visibleEdges}/${totalEdges}<br>
                üéØ Filters: ${filterText}<br>
                üîÄ Logic: ${filterMode}
            `;
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (event) => {
            if (!sigmaInstance) return;
            
            switch(event.key) {
                case '+':
                case '=':
                    zoomIn();
                    break;
                case '-':
                    zoomOut();
                    break;
                case 'r':
                case 'R':
                    resetView();
                    break;
                case 'l':
                case 'L':
                    toggleLabels();
                    break;
            }
        });
        
        // Initialize
        document.getElementById('file-input').addEventListener('change', function() {
            if (this.files[0]) {
                setStatus('File selected: ' + this.files[0].name);
            }
        });
    </script>
</body>
</html>