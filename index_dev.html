<!DOCTYPE html>
<html>
<head>
    <title>Startup Network Viewer</title>
    <meta charset="utf-8">
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            font-family: Arial, sans-serif; 
            background-color: #f5f5f5;
        }
        
        #header {
            background-color: #2c3e50;
            color: white;
            padding: 15px 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        #header h1 {
            margin: 0;
            font-size: 24px;
        }
        
        #controls {
            position: absolute;
            top: 80px;
            left: 20px;
            z-index: 1000;
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-width: 250px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
        }
        
        #controls h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #2c3e50;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #34495e;
            font-size: 13px;
        }
        
        button {
            background-color: #34495e;
            color: white;
            border: none;
            padding: 8px 15px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }
        
        button:hover {
            background-color: #2c3e50;
        }
        
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        
        .btn-primary {
            background-color: #3498db;
        }
        
        .btn-primary:hover {
            background-color: #2980b9;
        }
        
        .btn-success {
            background-color: #27ae60;
        }
        
        .btn-success:hover {
            background-color: #229954;
        }
        
        .btn-small {
            font-size: 11px;
            padding: 5px 10px;
        }
        
        .filter-section {
            margin-bottom: 10px;
            padding: 8px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #e9ecef;
        }
        
        .filter-section label {
            font-size: 11px;
            margin-bottom: 5px;
        }
        
        .checkbox-label {
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 3px;
            font-weight: normal;
        }
        
        .submenu {
            margin-left: 20px;
            margin-top: 5px;
            padding-left: 10px;
            border-left: 2px solid #e9ecef;
            display: none;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .submenu.active {
            display: block;
        }
        
        .value-checkbox {
            font-size: 10px;
            margin: 2px 0;
        }
        
        #legend {
            position: absolute;
            top: 80px;
            right: 20px;
            z-index: 1000;
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-width: 200px;
            max-width: 300px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
        }
        
        #legend h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #2c3e50;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 11px;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        
        .legend-label {
            color: #34495e;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        input[type="text"] {
            width: 100%;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 12px;
        }
        
        #sigma-container {
            width: 100%;
            height: calc(100vh - 60px);
            background-color: #ffffff;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #7f8c8d;
            font-size: 18px;
            z-index: 500;
        }
        
        #stats {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: white;
            padding: 10px 15px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            font-size: 12px;
            color: #7f8c8d;
        }
        
        .hidden {
            display: none;
        }
        
        #layout-controls {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>üåê Startup Network Viewer</h1>
    </div>
    
    <div id="loading">
        <div>üìä Loading network data...</div>
        <div style="margin-top: 10px; font-size: 14px;">Please wait while we build the graph</div>
    </div>
    
    <div id="controls" class="hidden">
        <h3>üéõÔ∏è Controls</h3>
        
        <div class="control-group">
            <label>Layout:</label>
            <div id="layout-controls">
                <button onclick="runForceAtlas2()" class="btn-primary btn-small" id="layout-btn">‚ñ∂Ô∏è Run Layout</button>
                <button onclick="stopLayout()" class="btn-small" id="stop-btn" disabled>‚è∏Ô∏è Stop</button>
                <button onclick="resetPositions()" class="btn-small">üîÑ Reset Positions</button>
            </div>
            <div style="margin-top: 5px; font-size: 10px; color: #7f8c8d;">
                <span id="layout-status">Ready</span>
            </div>
        </div>
        
        <div class="control-group">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <label>Layout Settings:</label>
                <button onclick="toggleAdvancedSettings()" style="padding: 4px 8px; font-size: 10px; cursor: pointer; background: #3498db; color: white; border: none; border-radius: 4px;">Advanced ‚öôÔ∏è</button>
            </div>
            
            <div id="advanced-settings" class="hidden">
            
            <div style="margin-bottom: 8px;">
                <label style="font-size: 11px;">Gravity:</label>
                <input type="number" id="gravity" min="0.01" max="2" step="0.01" value="2" style="width: 100%; padding: 4px;" oninput="updateLayoutSettingDisplay()">
            </div>
            
            <div style="margin-bottom: 8px;">
                <label style="font-size: 11px;">Scaling Ratio (Repulsion):</label>
                <input type="number" id="scaling-ratio" min="1" max="50" step="1" value="10" style="width: 100%; padding: 4px;" oninput="updateLayoutSettingDisplay()">
            </div>
            
            <div style="margin-bottom: 8px;">
                <label class="checkbox-label">
                    <input type="checkbox" id="barnes-hut" checked> Barnes-Hut Optimization
                </label>
            </div>
            
            <div style="margin-bottom: 8px;">
                <label class="checkbox-label">
                    <input type="checkbox" id="strong-gravity" checked> Strong Gravity Mode
                </label>
            </div>
            
            <div style="margin-bottom: 8px;">
                <label class="checkbox-label">
                    <input type="checkbox" id="lin-log-mode"> LinLog Mode
                </label>
            </div>
            
            </div>
        </div>
        
        <div class="control-group">
            <label>Node Size:</label>
            <input type="range" id="node-size" min="1" max="10" value="3" oninput="updateNodeSize(this.value)">
            <span id="node-size-value">3</span>
        </div>
        
        <div class="control-group">
            <label>Edge Thickness:</label>
            <input type="range" id="edge-size" min="0.5" max="3" step="0.5" value="1" oninput="updateEdgeSize(this.value)">
            <span id="edge-size-value">1</span>
        </div>
        
        <div class="control-group">
            <label>Display:</label>
            <button onclick="toggleLabels()" id="labels-toggle">üè∑Ô∏è Hide Labels</button>
        </div>
        
        <div class="control-group">
            <label>üîç Filters:</label>
            <button onclick="toggleFilterMode()" id="filter-mode-btn" style="font-size: 11px; padding: 4px 8px; margin-bottom: 8px;">Logic: OR</button>
            
            <div class="filter-section">
                <label>Connection Types:</label>
                <div>
                    <label class="checkbox-label">
                        <input type="checkbox" id="filter-competency" onchange="toggleConnectionType('competency')"> Competencies
                    </label>
                    <div id="submenu-competency" class="submenu"></div>
                    
                    <label class="checkbox-label">
                        <input type="checkbox" id="filter-impact" onchange="toggleConnectionType('impact')"> Impact
                    </label>
                    <div id="submenu-impact" class="submenu"></div>
                    
                    <label class="checkbox-label">
                        <input type="checkbox" id="filter-city" onchange="toggleConnectionType('city')"> Cities
                    </label>
                    <div id="submenu-city" class="submenu"></div>
                    
                    <label class="checkbox-label">
                        <input type="checkbox" id="filter-country" onchange="toggleConnectionType('country')"> Countries
                    </label>
                    <div id="submenu-country" class="submenu"></div>
                    
                    <label class="checkbox-label">
                        <input type="checkbox" id="filter-region" onchange="toggleConnectionType('region')"> Regions
                    </label>
                    <div id="submenu-region" class="submenu"></div>
                </div>
            </div>
            
            <div class="filter-section">
                <label>Node Display:</label>
                <label class="checkbox-label">
                    <input type="checkbox" id="show-all-nodes" checked onchange="updateFilters()"> Show All Nodes
                </label>
                <div style="font-size: 9px; color: #7f8c8d; margin-top: 3px;">
                    When unchecked, only shows nodes with visible connections
                </div>
            </div>
            
            <div class="filter-section">
                <label>Edge Weight:</label>
                <div style="display: flex; gap: 5px; align-items: center; font-size: 11px;">
                    <span>Min:</span>
                    <input type="range" id="weight-min" min="1" max="20" value="1" style="width: 60px;" oninput="updateFilters()">
                    <span id="weight-min-value">1</span>
                    <span>Max:</span>
                    <input type="range" id="weight-max" min="1" max="20" value="20" style="width: 60px;" oninput="updateFilters()">
                    <span id="weight-max-value">20</span>
                </div>
            </div>
            
            <div class="filter-section">
                <label>Search Nodes:</label>
                <input type="text" id="search-nodes" placeholder="Type to search..." oninput="updateFilters()">
            </div>
            
            <button onclick="clearAllFilters()" class="btn-small">Clear All Filters</button>
        </div>
    </div>
    
    <div id="sigma-container"></div>
    
    <div id="stats" class="hidden">
        <div id="graph-stats"></div>
    </div>
    
            <div id="legend" class="hidden">
                <h3>üé® Legend</h3>
                <div style="margin-bottom: 12px; padding: 8px; background: #f8f9fa; border-radius: 4px;">
                    <div style="font-size: 11px; color: #7f8c8d; margin-bottom: 6px;">Apply geographic colors to:</div>
                    <div style="display: flex; gap: 12px; font-size: 11px;">
                        <label style="cursor: pointer; display: flex; align-items: center; gap: 4px;">
                            <input type="radio" name="colorMode" value="node" checked onchange="toggleColorMode('node')">
                            Nodes
                        </label>
                        <label style="cursor: pointer; display: flex; align-items: center; gap: 4px;">
                            <input type="radio" name="colorMode" value="edge" onchange="toggleColorMode('edge')">
                            Edges
                        </label>
                    </div>
                </div>
                <div id="legend-content"></div>
            </div>    <!-- Include graphology and sigma.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/graphology@0.25.4/dist/graphology.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sigma@2.4.0/build/sigma.min.js"></script>
    <script type="module">
        import forceAtlas2 from 'https://cdn.jsdelivr.net/npm/graphology-layout-forceatlas2@0.10.1/+esm';
        window.forceAtlas2 = forceAtlas2;
    </script>
    
    <script>
        let sigmaInstance = null;
        let graph = null;
        let showLabels = true;
        let layoutWorker = null;
        let layoutRunning = false;
        let originalNodeColors = new Map();
        let originalEdgeColors = new Map();
        let originalEdgeSizes = new Map();
        let filterMode = 'OR'; // 'OR' or 'AND'
        let colorMode = 'node'; // 'node' or 'edge' - determines where geographic colors are applied
        let activeFilters = {
            types: [],
            values: {}, // e.g., { competency: ['Hydrogen', 'Battery'], region: ['Berlin'] }
            weightMin: 1,
            weightMax: 20,
            searchText: '',
            showAllNodes: true
        };
        
        // High-contrast color palette for dynamic assignment
        // Colors are assigned in order as checkboxes are checked
        const diversePalette = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#e67e22', '#34495e', '#e91e63', '#00bcd4',
            '#ff5722', '#8bc34a', '#673ab7', '#ff9800', '#009688',
            '#795548', '#607d8b', '#ffc107', '#cddc39', '#03a9f4'
        ];
        let nextColorIndex = 0; // Track next color to assign
        
        // Track available values for each connection type
        let availableValues = {
            competency: new Set(),
            impact: new Set(),
            city: new Set(),
            country: new Set(),
            region: new Set()
        };
        
        // Color assignments for specific values
        let valueColors = {};
        
        // Initialize by loading the JSON data
        async function init() {
            try {
                console.log('Loading network data...');
                const response = await fetch('network_data.json');
                const data = await response.json();
                
                console.log(`Loaded ${data.nodes.length} nodes and ${data.edges.length} edges`);
                
                // Create graph using graphology (accessing from global)
                const Graph = graphology.Graph;
                graph = new Graph({ type: 'undirected' });
                
                // Add nodes
                data.nodes.forEach(node => {
                    const nodeColor = '#95a5a6';
                    graph.addNode(node.id, {
                        label: node.label,
                        x: Math.random() * 100,
                        y: Math.random() * 100,
                        size: 3,
                        color: nodeColor,
                        description: node.description || '',
                        website: node.website || '',
                        logo_url: node.logo_url || ''
                    });
                    originalNodeColors.set(node.id, nodeColor);
                });
                
                // Add edges
                data.edges.forEach(edge => {
                    try {
                        const edgeAttrs = {
                            weight: edge.weight,
                            size: Math.min(3, edge.weight * 0.3),
                            color: '#bdc3c7',
                            label: edge.label_detailed || edge.label,
                            types: edge.types || [],
                            is_competency: edge.is_competency || false,
                            is_impact: edge.is_impact || false,
                            is_city: edge.is_city || false,
                            is_country: edge.is_country || false,
                            is_region: edge.is_region || false,
                            competencies: edge.competencies || [],
                            impacts: edge.impacts || [],
                            cities: edge.cities || [],
                            countries: edge.countries || [],
                            regions: edge.regions || []
                        };
                        
                        graph.addEdge(edge.source, edge.target, edgeAttrs);
                        
                        // Store original color and size for hover interactions
                        const edgeKey = graph.edge(edge.source, edge.target);
                        originalEdgeColors.set(edgeKey, '#bdc3c7');
                        originalEdgeSizes.set(edgeKey, edgeAttrs.size);
                    } catch (e) {
                        // Edge might already exist, skip
                        console.warn(`Skipping duplicate edge: ${edge.source} - ${edge.target}`);
                    }
                });
                
                console.log(`Graph built: ${graph.order} nodes, ${graph.size} edges`);
                
                // Create sigma instance (check if Sigma exists in global scope)
                if (typeof Sigma === 'undefined') {
                    throw new Error('Sigma is not defined - library did not load correctly');
                }
                
                sigmaInstance = new Sigma(graph, document.getElementById('sigma-container'), {
                    renderLabels: showLabels,
                    renderEdgeLabels: false,
                    labelFont: 'Arial',
                    labelSize: 12,
                    labelWeight: 'normal',
                    minCameraRatio: 0.1,
                    maxCameraRatio: 10,
                    enableEdgeHoverEvents: true,
                    enableEdgeClickEvents: true
                });
                
                // Setup interactions
                setupHoverInteractions();
                
                // Collect available values and build submenus
                collectAvailableValues();
                buildValueSubmenus();
                
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('controls').classList.remove('hidden');
                document.getElementById('stats').classList.remove('hidden');
                document.getElementById('legend').classList.remove('hidden');
                
                updateStats();
                updateLegend();
                
                console.log('‚úÖ Initialization complete');
                
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('loading').innerHTML = 
                    `<div style="color: #e74c3c;">‚ùå Error loading network data</div>
                     <div style="font-size: 14px; margin-top: 10px;">${error.message}</div>`;
            }
        }
        
        function collectAvailableValues() {
            // Scan all edges to find unique values for each connection type
            graph.forEachEdge((edge, attributes) => {
                if (attributes.competencies) {
                    attributes.competencies.forEach(val => availableValues.competency.add(val));
                }
                if (attributes.impacts) {
                    attributes.impacts.forEach(val => availableValues.impact.add(val));
                }
                if (attributes.cities) {
                    attributes.cities.forEach(val => availableValues.city.add(val));
                }
                if (attributes.countries) {
                    attributes.countries.forEach(val => availableValues.country.add(val));
                }
                if (attributes.regions) {
                    attributes.regions.forEach(val => availableValues.region.add(val));
                }
            });
            
            console.log('Available values collected:', {
                competencies: availableValues.competency.size,
                impacts: availableValues.impact.size,
                cities: availableValues.city.size,
                countries: availableValues.country.size,
                regions: availableValues.region.size
            });
        }
        
        function buildValueSubmenus() {
            const types = ['competency', 'impact', 'city', 'country', 'region'];
            
            types.forEach(type => {
                const submenu = document.getElementById(`submenu-${type}`);
                const values = Array.from(availableValues[type]).sort();
                
                if (values.length === 0) {
                    submenu.innerHTML = '<div style="font-size: 10px; color: #95a5a6; padding: 5px;">No values found</div>';
                    return;
                }
                
                values.forEach(value => {
                    const label = document.createElement('label');
                    label.className = 'checkbox-label value-checkbox';
                    label.innerHTML = `
                        <input type="checkbox" 
                               data-type="${type}" 
                               data-value="${value}" 
                               onchange="updateValueFilter('${type}', '${value}', this.checked)">
                        ${value}
                    `;
                    submenu.appendChild(label);
                });
            });
        }
        
        function assignColorToValue(type, value) {
            // Assign next available color from diverse palette
            if (!valueColors[type]) valueColors[type] = {};
            if (!valueColors[type][value]) {
                valueColors[type][value] = diversePalette[nextColorIndex % diversePalette.length];
                nextColorIndex++;
            }
            return valueColors[type][value];
        }
        
        function toggleConnectionType(type) {
            const checkbox = document.getElementById(`filter-${type}`);
            const submenu = document.getElementById(`submenu-${type}`);
            
            if (checkbox.checked) {
                submenu.classList.add('active');
            } else {
                submenu.classList.remove('active');
                // Uncheck all value checkboxes
                const valueCheckboxes = submenu.querySelectorAll('input[type="checkbox"]');
                valueCheckboxes.forEach(cb => {
                    cb.checked = false;
                });
                // Clear this type from active filters
                if (activeFilters.values[type]) {
                    delete activeFilters.values[type];
                }
            }
            
            updateFilters();
        }
        
        function updateValueFilter(type, value, checked) {
            if (!activeFilters.values[type]) {
                activeFilters.values[type] = [];
            }
            
            if (checked) {
                if (!activeFilters.values[type].includes(value)) {
                    activeFilters.values[type].push(value);
                    // Assign color when checkbox is first checked
                    assignColorToValue(type, value);
                }
            } else {
                activeFilters.values[type] = activeFilters.values[type].filter(v => v !== value);
                if (activeFilters.values[type].length === 0) {
                    delete activeFilters.values[type];
                }
            }
            
            updateFilters();
        }
        
        function updateLegend() {
            const legendContent = document.getElementById('legend-content');
            legendContent.innerHTML = '';
            
            // Categorize filters by type
            const capabilityTypes = ['competency', 'impact'];
            const geoTypes = ['city', 'country', 'region'];
            const typeLabels = {
                competency: 'Competencies',
                impact: 'Impact',
                city: 'Cities',
                country: 'Countries',
                region: 'Regions'
            };
            
            let hasItems = false;
            
            // Add geographic filters section (node colors)
            const activeGeoTypes = geoTypes.filter(type => 
                activeFilters.values[type] && activeFilters.values[type].length > 0
            );
            
            if (activeGeoTypes.length > 0) {
                const geoHeader = document.createElement('div');
                geoHeader.style.fontWeight = 'bold';
                geoHeader.style.fontSize = '12px';
                geoHeader.style.marginBottom = '8px';
                geoHeader.style.color = '#2c3e50';
                geoHeader.innerHTML = colorMode === 'node' ? 'üìç Node Colors (Geography)' : 'üîó Edge Colors (Geography)';
                legendContent.appendChild(geoHeader);
                
                activeGeoTypes.forEach(type => {
                    const subHeader = document.createElement('div');
                    subHeader.style.fontWeight = 'bold';
                    subHeader.style.marginTop = '8px';
                    subHeader.style.marginBottom = '4px';
                    subHeader.style.fontSize = '10px';
                    subHeader.style.color = '#7f8c8d';
                    subHeader.textContent = typeLabels[type];
                    legendContent.appendChild(subHeader);
                    
                    activeFilters.values[type].forEach(value => {
                        const item = document.createElement('div');
                        item.className = 'legend-item';
                        item.style.display = 'flex';
                        item.style.alignItems = 'center';
                        item.style.gap = '6px';
                        item.style.marginLeft = '8px';
                        
                        const colorPicker = document.createElement('input');
                        colorPicker.type = 'color';
                        colorPicker.value = valueColors[type][value];
                        colorPicker.style.width = '20px';
                        colorPicker.style.height = '20px';
                        colorPicker.style.border = 'none';
                        colorPicker.style.cursor = 'pointer';
                        colorPicker.style.padding = '0';
                        colorPicker.title = 'Click to change color';
                        colorPicker.addEventListener('change', (e) => {
                            valueColors[type][value] = e.target.value;
                            applyFilters();
                        });
                        
                        const label = document.createElement('span');
                        label.className = 'legend-label';
                        label.textContent = value;
                        label.style.flex = '1';
                        
                        item.appendChild(colorPicker);
                        item.appendChild(label);
                        legendContent.appendChild(item);
                    });
                });
                
                hasItems = true;
            }
            
            // Add capability filters section (edge colors)
            const activeCapTypes = capabilityTypes.filter(type => 
                activeFilters.values[type] && activeFilters.values[type].length > 0
            );
            
            if (activeCapTypes.length > 0) {
                const capHeader = document.createElement('div');
                capHeader.style.fontWeight = 'bold';
                capHeader.style.fontSize = '12px';
                capHeader.style.marginTop = hasItems ? '16px' : '0';
                capHeader.style.marginBottom = '8px';
                capHeader.style.color = '#2c3e50';
                capHeader.innerHTML = 'üîó Edge Colors (Capabilities)';
                legendContent.appendChild(capHeader);
                
                activeCapTypes.forEach(type => {
                    const subHeader = document.createElement('div');
                    subHeader.style.fontWeight = 'bold';
                    subHeader.style.marginTop = '8px';
                    subHeader.style.marginBottom = '4px';
                    subHeader.style.fontSize = '10px';
                    subHeader.style.color = '#7f8c8d';
                    subHeader.textContent = typeLabels[type];
                    legendContent.appendChild(subHeader);
                    
                    activeFilters.values[type].forEach(value => {
                        const item = document.createElement('div');
                        item.className = 'legend-item';
                        item.style.display = 'flex';
                        item.style.alignItems = 'center';
                        item.style.gap = '6px';
                        item.style.marginLeft = '8px';
                        
                        const colorPicker = document.createElement('input');
                        colorPicker.type = 'color';
                        colorPicker.value = valueColors[type][value];
                        colorPicker.style.width = '20px';
                        colorPicker.style.height = '20px';
                        colorPicker.style.border = 'none';
                        colorPicker.style.cursor = 'pointer';
                        colorPicker.style.padding = '0';
                        colorPicker.title = 'Click to change color';
                        colorPicker.addEventListener('change', (e) => {
                            valueColors[type][value] = e.target.value;
                            applyFilters();
                        });
                        
                        const label = document.createElement('span');
                        label.className = 'legend-label';
                        label.textContent = value;
                        label.style.flex = '1';
                        
                        item.appendChild(colorPicker);
                        item.appendChild(label);
                        legendContent.appendChild(item);
                    });
                });
                
                hasItems = true;
            }
            
            if (!hasItems) {
                legendContent.innerHTML = '<div style="font-size: 11px; color: #95a5a6;">Select filters to see legend</div>';
            }
        }
        
        function runForceAtlas2() {
            if (!graph || layoutRunning) return;
            
            console.log('Starting Force Atlas 2 layout...');
            
            if (typeof window.forceAtlas2 === 'undefined') {
                console.error('Force Atlas 2 library not loaded');
                document.getElementById('layout-status').textContent = 'Error: Layout library not loaded';
                return;
            }
            
            layoutRunning = true;
            document.getElementById('layout-btn').disabled = true;
            document.getElementById('stop-btn').disabled = false;
            document.getElementById('layout-status').textContent = 'Running...';
            
            // Get settings from UI controls
            const settings = {
                barnesHutOptimize: document.getElementById('barnes-hut').checked,
                strongGravityMode: document.getElementById('strong-gravity').checked,
                gravity: parseFloat(document.getElementById('gravity').value),
                scalingRatio: parseFloat(document.getElementById('scaling-ratio').value),
                slowDown: 5,
                edgeWeightInfluence: 1,
                linLogMode: document.getElementById('lin-log-mode').checked
            };
            
            console.log('Layout settings:', settings);
            
            // Create a filtered graph that only contains visible edges
            const Graph = graphology.Graph;
            const filteredGraph = new Graph({ type: 'undirected' });
            
            // Add all nodes with their positions
            graph.forEachNode((node, attributes) => {
                filteredGraph.addNode(node, attributes);
            });
            
            // Only add visible edges
            let visibleEdgeCount = 0;
            graph.forEachEdge((edge, attributes, source, target) => {
                if (!attributes.hidden) {
                    try {
                        filteredGraph.addEdge(source, target, attributes);
                        visibleEdgeCount++;
                    } catch (e) {
                        // Edge might already exist, skip
                    }
                }
            });
            
            console.log(`Running layout on ${filteredGraph.order} nodes and ${visibleEdgeCount} visible edges`);
            
            if (visibleEdgeCount === 0) {
                console.warn('No visible edges to layout');
                document.getElementById('layout-status').textContent = 'No edges to layout';
                stopLayout();
                return;
            }
            
            let iteration = 0;
            const maxIterations = 300;
            
            layoutWorker = setInterval(() => {
                if (iteration >= maxIterations) {
                    stopLayout();
                    return;
                }
                
                // Run layout on filtered graph
                window.forceAtlas2.assign(filteredGraph, { iterations: 1, settings: settings });
                
                // Copy positions back to original graph
                filteredGraph.forEachNode((node, attributes) => {
                    graph.setNodeAttribute(node, 'x', attributes.x);
                    graph.setNodeAttribute(node, 'y', attributes.y);
                });
                
                sigmaInstance.refresh();
                iteration++;
                
                if (iteration % 10 === 0) {
                    document.getElementById('layout-status').textContent = 
                        `Running... ${Math.round((iteration / maxIterations) * 100)}%`;
                }
            }, 10);
        }
        
        function updateLayoutSettingDisplay() {
            // No display updates needed for number inputs
        }
        
        function stopLayout() {
            if (layoutWorker) {
                clearInterval(layoutWorker);
                layoutWorker = null;
            }
            layoutRunning = false;
            document.getElementById('layout-btn').disabled = false;
            document.getElementById('stop-btn').disabled = true;
            document.getElementById('layout-status').textContent = 'Ready';
            console.log('Layout stopped');
        }
        
        function resetPositions() {
            if (!graph) return;
            
            stopLayout();
            
            // Randomize positions
            graph.forEachNode((node) => {
                graph.setNodeAttribute(node, 'x', Math.random() * 100);
                graph.setNodeAttribute(node, 'y', Math.random() * 100);
            });
            
            sigmaInstance.refresh();
            resetView();
        }
        
        function setupHoverInteractions() {
            if (!sigmaInstance) return;
            
            let hoveredNode = null;
            let hoveredEdge = null;
            
            // Node hover events
            sigmaInstance.on('enterNode', (event) => {
                hoveredNode = event.node;
                const nodeAttributes = graph.getNodeAttributes(event.node);
                
                // Get connected nodes
                const connectedNodes = [];
                graph.forEachEdge((edge, attributes) => {
                    const [source, target] = graph.extremities(edge);
                    if ((source === event.node || target === event.node) && !attributes.hidden) {
                        const connectedNode = source === event.node ? target : source;
                        const connectedAttrs = graph.getNodeAttributes(connectedNode);
                        connectedNodes.push(connectedAttrs.label || connectedNode);
                    }
                });
                
                // Show tooltip with all attributes
                showHoverTooltip(event.event.x, event.event.y, {
                    title: nodeAttributes.label || event.node,
                    type: 'node',
                    attributes: nodeAttributes,
                    connectedNodes: connectedNodes
                });
                
                // Highlight connected edges
                graph.forEachEdge((edge, attributes) => {
                    const [source, target] = graph.extremities(edge);
                    if ((source === event.node || target === event.node) && !attributes.hidden) {
                        const originalSize = originalEdgeSizes.get(edge) || 1;
                        graph.setEdgeAttribute(edge, 'color', '#ff6b6b');
                        graph.setEdgeAttribute(edge, 'size', originalSize * 2);
                    }
                });
                
                sigmaInstance.refresh();
            });
            
            sigmaInstance.on('leaveNode', (event) => {
                if (hoveredNode === event.node) {
                    hoveredNode = null;
                    hideHoverTooltip();
                    
                    // Reapply filters to restore the correct filtered colors and sizes
                    applyFilters();
                }
            });
            
            sigmaInstance.on('clickNode', (event) => {
                const nodeData = graph.getNodeAttributes(event.node);
                console.log('Clicked node:', event.node, nodeData);
                
                if (nodeData.website) {
                    window.open(nodeData.website, '_blank');
                }
            });
            
            // Edge hover events
            sigmaInstance.on('enterEdge', (event) => {
                console.log('enterEdge fired:', event);
                const edge = event.edge;
                const edgeAttributes = graph.getEdgeAttributes(edge);
                console.log('Edge attributes:', edgeAttributes);
                if (edgeAttributes.hidden) return;
                
                hoveredEdge = edge;
                
                const [source, target] = graph.extremities(edge);
                const sourceAttrs = graph.getNodeAttributes(source);
                const targetAttrs = graph.getNodeAttributes(target);
                
                // Highlight the edge - make it red and 3x bigger
                const originalSize = originalEdgeSizes.get(edge) || 1;
                graph.setEdgeAttribute(edge, 'color', '#e74c3c');
                graph.setEdgeAttribute(edge, 'size', originalSize * 3);
                sigmaInstance.refresh();
                
                // Build tooltip content
                let tooltipHTML = `<strong>${sourceAttrs.label}</strong> ‚Üî <strong>${targetAttrs.label}</strong><br><br>`;
                tooltipHTML += `<strong>Shared Connections (${edgeAttributes.weight}):</strong><br>`;
                
                const connections = [];
                if (edgeAttributes.competencies && edgeAttributes.competencies.length > 0) {
                    connections.push(`<span style="color: #f39c12;">‚óè</span> <strong>Competencies:</strong> ${edgeAttributes.competencies.join(', ')}`);
                }
                if (edgeAttributes.impacts && edgeAttributes.impacts.length > 0) {
                    connections.push(`<span style="color: #9b59b6;">‚óè</span> <strong>Impacts:</strong> ${edgeAttributes.impacts.join(', ')}`);
                }
                if (edgeAttributes.cities && edgeAttributes.cities.length > 0) {
                    connections.push(`<span style="color: #e74c3c;">‚óè</span> <strong>Cities:</strong> ${edgeAttributes.cities.join(', ')}`);
                }
                if (edgeAttributes.countries && edgeAttributes.countries.length > 0) {
                    connections.push(`<span style="color: #2ecc71;">‚óè</span> <strong>Countries:</strong> ${edgeAttributes.countries.join(', ')}`);
                }
                if (edgeAttributes.regions && edgeAttributes.regions.length > 0) {
                    connections.push(`<span style="color: #3498db;">‚óè</span> <strong>Regions:</strong> ${edgeAttributes.regions.join(', ')}`);
                }
                
                tooltipHTML += connections.join('<br>');
                
                // Show tooltip
                showHoverTooltip(event.event.x, event.event.y, {
                    title: tooltipHTML,
                    type: 'edge',
                    attributes: edgeAttributes,
                    source: source,
                    target: target,
                    isHTML: true
                });
            });
            
            sigmaInstance.on('leaveEdge', (event) => {
                const edge = event.edge;
                if (hoveredEdge === edge) {
                    hoveredEdge = null;
                    hideHoverTooltip();
                    
                    // Reapply filters to restore the correct filtered colors and sizes
                    applyFilters();
                }
            });
        }
        
        function showHoverTooltip(x, y, data) {
            let tooltip = document.getElementById('hover-tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'hover-tooltip';
                tooltip.style.position = 'absolute';
                tooltip.style.background = 'rgba(0,0,0,0.9)';
                tooltip.style.color = 'white';
                tooltip.style.padding = '12px';
                tooltip.style.borderRadius = '6px';
                tooltip.style.fontSize = '13px';
                tooltip.style.zIndex = '10000';
                tooltip.style.pointerEvents = 'none';
                tooltip.style.maxWidth = '400px';
                tooltip.style.maxHeight = '500px';
                tooltip.style.overflowY = 'auto';
                tooltip.style.lineHeight = '1.4';
                tooltip.style.boxShadow = '0 4px 6px rgba(0,0,0,0.3)';
                document.body.appendChild(tooltip);
            }
            
            let content;
            if (data.isHTML) {
                content = data.title;
            } else if (data.type === 'node' && data.attributes) {
                // Enhanced node tooltip with all attributes
                content = `<strong style="font-size: 14px;">${data.title}</strong><br><br>`;
                
                // Show all node attributes
                if (data.attributes.description) {
                    content += `<div style="margin-bottom: 8px;"><strong>Description:</strong><br>${data.attributes.description}</div>`;
                }
                if (data.attributes.website) {
                    content += `<div style="margin-bottom: 8px;"><strong>Website:</strong><br><a href="${data.attributes.website}" target="_blank" style="color: #3498db;">${data.attributes.website}</a></div>`;
                }
                
                // Show connected companies
                if (data.connectedNodes && data.connectedNodes.length > 0) {
                    content += `<div style="margin-top: 12px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 8px;">`;
                    content += `<strong>Connected to ${data.connectedNodes.length} companies:</strong><br>`;
                    content += `<div style="margin-top: 6px; font-size: 11px; max-height: 200px; overflow-y: auto;">`;
                    data.connectedNodes.forEach(node => {
                        content += `‚Ä¢ ${node}<br>`;
                    });
                    content += `</div></div>`;
                }
            } else {
                content = `<strong>${data.title}</strong>`;
                if (data.type === 'edge' && data.source && data.target) {
                    content += `<br><small>From: ${data.source}<br>To: ${data.target}</small>`;
                    if (data.attributes && data.attributes.weight) {
                        content += `<br><small>Weight: ${data.attributes.weight}</small>`;
                    }
                }
            }
            
            tooltip.innerHTML = content;
            tooltip.style.left = (x + 15) + 'px';
            tooltip.style.top = (y + 15) + 'px';
            tooltip.style.display = 'block';
        }
        
        function hideHoverTooltip() {
            const tooltip = document.getElementById('hover-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }
        
        function zoomIn() {
            if (sigmaInstance) {
                const camera = sigmaInstance.getCamera();
                camera.animatedZoom({ duration: 200 });
            }
        }
        
        function zoomOut() {
            if (sigmaInstance) {
                const camera = sigmaInstance.getCamera();
                camera.animatedUnzoom({ duration: 200 });
            }
        }
        
        function resetView() {
            if (sigmaInstance) {
                const camera = sigmaInstance.getCamera();
                camera.animatedReset({ duration: 500 });
            }
        }
        
        function updateNodeSize(value) {
            document.getElementById('node-size-value').textContent = value;
            if (graph && sigmaInstance) {
                graph.forEachNode((node) => {
                    graph.setNodeAttribute(node, 'size', parseFloat(value));
                });
                sigmaInstance.refresh();
            }
        }
        
        function updateEdgeSize(value) {
            document.getElementById('edge-size-value').textContent = value;
            if (graph && sigmaInstance) {
                graph.forEachEdge((edge, attributes) => {
                    const thickness = Math.max(0.5, attributes.weight * parseFloat(value) * 0.3);
                    graph.setEdgeAttribute(edge, 'size', thickness);
                });
                sigmaInstance.refresh();
            }
        }
        
        function toggleLabels() {
            showLabels = !showLabels;
            if (sigmaInstance) {
                sigmaInstance.setSetting('renderLabels', showLabels);
                sigmaInstance.refresh();
            }
            document.getElementById('labels-toggle').textContent = 
                showLabels ? 'üè∑Ô∏è Hide Labels' : 'üè∑Ô∏è Show Labels';
        }
        
        function toggleColorMode(mode) {
            colorMode = mode;
            applyFilters();
        }
        
        function toggleAdvancedSettings() {
            const advancedSettings = document.getElementById('advanced-settings');
            advancedSettings.classList.toggle('hidden');
        }
        
        function toggleColorMode(mode) {
            colorMode = mode;
            applyFilters();
        }
        
        function toggleAdvancedSettings() {
            const advancedSettings = document.getElementById('advanced-settings');
            advancedSettings.classList.toggle('hidden');
        }
        
        function toggleFilterMode() {
            filterMode = filterMode === 'OR' ? 'AND' : 'OR';
            const btn = document.getElementById('filter-mode-btn');
            btn.textContent = `Logic: ${filterMode}`;
            btn.style.backgroundColor = filterMode === 'AND' ? '#27ae60' : '#34495e';
            updateFilters();
        }
        
        function clearAllFilters() {
            ['filter-competency', 'filter-impact', 'filter-city', 'filter-country', 'filter-region'].forEach(id => {
                document.getElementById(id).checked = false;
            });
            
            document.getElementById('weight-min').value = 1;
            document.getElementById('weight-max').value = 20;
            document.getElementById('search-nodes').value = '';
            document.getElementById('show-all-nodes').checked = true;
            
            activeFilters = {
                types: [],
                values: {},
                weightMin: 1,
                weightMax: 20,
                searchText: '',
                showAllNodes: true
            };
            
            updateFilters();
        }
        
        function updateFilters() {
            const weightMin = parseInt(document.getElementById('weight-min').value);
            const weightMax = parseInt(document.getElementById('weight-max').value);
            document.getElementById('weight-min-value').textContent = weightMin;
            document.getElementById('weight-max-value').textContent = weightMax;
            
            const typeFilters = [];
            ['competency', 'impact', 'city', 'country', 'region'].forEach(type => {
                if (document.getElementById(`filter-${type}`).checked) {
                    typeFilters.push(type);
                }
            });
            
            // Preserve the values object when updating filters
            const currentValues = activeFilters.values || {};
            
            activeFilters = {
                types: typeFilters,
                values: currentValues,
                weightMin: weightMin,
                weightMax: weightMax,
                searchText: document.getElementById('search-nodes').value.toLowerCase().trim(),
                showAllNodes: document.getElementById('show-all-nodes').checked
            };
            
            applyFilters();
        }
        
        function applyFilters() {
            if (!graph || !sigmaInstance) return;
            
            // Show all initially and reset colors
            graph.forEachNode((node) => {
                graph.setNodeAttribute(node, 'hidden', false);
                const originalColor = originalNodeColors.get(node) || '#95a5a6';
                graph.setNodeAttribute(node, 'color', originalColor);
            });
            
            graph.forEachEdge((edge) => {
                graph.setEdgeAttribute(edge, 'hidden', false);
                const originalColor = originalEdgeColors.get(edge) || '#bdc3c7';
                const originalSize = originalEdgeSizes.get(edge) || 1;
                graph.setEdgeAttribute(edge, 'color', originalColor);
                graph.setEdgeAttribute(edge, 'size', originalSize);
            });
            
            // Apply edge type filters (with value-specific filtering)
            if (activeFilters.types.length > 0) {
                graph.forEachEdge((edge, attributes) => {
                    let shouldShow;
                    
                    if (filterMode === 'OR') {
                        // OR logic: show edge if it matches ANY selected type
                        shouldShow = activeFilters.types.some(type => {
                            // First check if this edge has this type
                            if (attributes[`is_${type}`] !== true) return false;
                            
                            // If specific values are selected for this type, check those
                            if (activeFilters.values[type] && activeFilters.values[type].length > 0) {
                                const edgeValues = attributes[`${type === 'competency' ? 'competencies' : 
                                                              type === 'impact' ? 'impacts' : 
                                                              type === 'city' ? 'cities' : 
                                                              type === 'country' ? 'countries' : 'regions'}`] || [];
                                // Edge must have at least one of the selected values
                                return activeFilters.values[type].some(val => edgeValues.includes(val));
                            }
                            
                            return true;
                        });
                    } else {
                        // AND logic: show edge if it matches ALL selected types
                        shouldShow = activeFilters.types.every(type => {
                            // First check if this edge has this type
                            if (attributes[`is_${type}`] !== true) return false;
                            
                            // If specific values are selected for this type, check those
                            if (activeFilters.values[type] && activeFilters.values[type].length > 0) {
                                const edgeValues = attributes[`${type === 'competency' ? 'competencies' : 
                                                              type === 'impact' ? 'impacts' : 
                                                              type === 'city' ? 'cities' : 
                                                              type === 'country' ? 'countries' : 'regions'}`] || [];
                                // Edge must have at least one of the selected values
                                return activeFilters.values[type].some(val => edgeValues.includes(val));
                            }
                            
                            return true;
                        });
                    }
                    
                    graph.setEdgeAttribute(edge, 'hidden', !shouldShow);
                    
                    // Color code EDGES only for non-geographic types (competency, impact)
                    if (shouldShow) {
                        let assignedColor = null;
                        
                        // Only color edges for capability/impact filters
                        for (const type of ['competency', 'impact']) {
                            if (activeFilters.values[type] && activeFilters.values[type].length > 0 && attributes[`is_${type}`]) {
                                const edgeValues = attributes[`${type === 'competency' ? 'competencies' : 'impacts'}`] || [];
                                
                                // Find first matching value
                                for (const value of activeFilters.values[type]) {
                                    if (edgeValues.includes(value)) {
                                        assignedColor = valueColors[type][value];
                                        break;
                                    }
                                }
                                
                                if (assignedColor) break;
                            }
                        }
                        
                        if (assignedColor) {
                            graph.setEdgeAttribute(edge, 'color', assignedColor);
                        } else if (activeFilters.types.length === 1 && (activeFilters.types[0] === 'competency' || activeFilters.types[0] === 'impact')) {
                            // Fallback: color by type if single capability filter
                            const type = activeFilters.types[0];
                            const colors = {
                                'competency': '#f39c12',
                                'impact': '#9b59b6'
                            };
                            graph.setEdgeAttribute(edge, 'color', colors[type] || '#bdc3c7');
                        }
                    }
                });
            }
            
            // Apply weight filters
            graph.forEachEdge((edge, attributes) => {
                if (!attributes.hidden) {
                    const weight = attributes.weight || 1;
                    if (weight < activeFilters.weightMin || weight > activeFilters.weightMax) {
                        graph.setEdgeAttribute(edge, 'hidden', true);
                    }
                }
            });
            
            // Apply geographic colors based on colorMode (nodes or edges)
            const geoTypes = ['city', 'country', 'region'];
            const activeGeoFilters = geoTypes.filter(type => 
                activeFilters.values[type] && activeFilters.values[type].length > 0
            );
            
            if (activeGeoFilters.length > 0) {
                if (colorMode === 'node') {
                    // COLOR NODES based on geographic filters
                    const nodeGeoValues = new Map();
                    
                    graph.forEachEdge((edge, attributes) => {
                        if (attributes.hidden) return;
                        
                        const [source, target] = graph.extremities(edge);
                        
                        // Check if this edge matches any geographic filter
                        for (const type of activeGeoFilters) {
                            const edgeValues = attributes[`${type === 'city' ? 'cities' : 
                                                          type === 'country' ? 'countries' : 'regions'}`] || [];
                            
                            for (const value of activeFilters.values[type]) {
                                if (edgeValues.includes(value)) {
                                    if (!nodeGeoValues.has(source)) nodeGeoValues.set(source, new Set());
                                    if (!nodeGeoValues.has(target)) nodeGeoValues.set(target, new Set());
                                    nodeGeoValues.get(source).add({type, value});
                                    nodeGeoValues.get(target).add({type, value});
                                }
                            }
                        }
                    });
                    
                    nodeGeoValues.forEach((geoSet, nodeId) => {
                        const firstGeo = Array.from(geoSet)[0];
                        if (firstGeo && valueColors[firstGeo.type] && valueColors[firstGeo.type][firstGeo.value]) {
                            graph.setNodeAttribute(nodeId, 'color', valueColors[firstGeo.type][firstGeo.value]);
                        }
                    });
                } else {
                    // COLOR EDGES based on geographic filters
                    graph.forEachEdge((edge, attributes) => {
                        if (attributes.hidden) return;
                        
                        let assignedColor = null;
                        
                        for (const type of activeGeoFilters) {
                            if (attributes[`is_${type}`]) {
                                const edgeValues = attributes[`${type === 'city' ? 'cities' : 
                                                              type === 'country' ? 'countries' : 'regions'}`] || [];
                                
                                for (const value of activeFilters.values[type]) {
                                    if (edgeValues.includes(value)) {
                                        assignedColor = valueColors[type][value];
                                        break;
                                    }
                                }
                                
                                if (assignedColor) break;
                            }
                        }
                        
                        if (assignedColor) {
                            graph.setEdgeAttribute(edge, 'color', assignedColor);
                        }
                    });
                }
            }
            
            // Apply node search filter
            if (activeFilters.searchText) {
                graph.forEachNode((node, attributes) => {
                    if (!attributes.label?.toLowerCase().includes(activeFilters.searchText)) {
                        graph.setNodeAttribute(node, 'hidden', true);
                    }
                });
            }
            
            // Hide nodes with no visible edges (unless showAllNodes is checked)
            if (!activeFilters.showAllNodes && (activeFilters.types.length > 0 || activeFilters.weightMin > 1 || activeFilters.weightMax < 20)) {
                graph.forEachNode((node, attributes) => {
                    if (!attributes.hidden) {
                        const hasVisibleEdge = graph.edges(node).some(edge => 
                            !graph.getEdgeAttribute(edge, 'hidden')
                        );
                        if (!hasVisibleEdge) {
                            graph.setNodeAttribute(node, 'hidden', true);
                        }
                    }
                });
            }
            
            sigmaInstance.refresh();
            updateStats();
            updateLegend();
        }
        
        function updateStats() {
            if (!graph) return;
            
            let visibleNodes = 0;
            let visibleEdges = 0;
            
            graph.forEachNode((node, attributes) => {
                if (!attributes.hidden) visibleNodes++;
            });
            
            graph.forEachEdge((edge, attributes) => {
                if (!attributes.hidden) visibleEdges++;
            });
            
            const statsEl = document.getElementById('graph-stats');
            statsEl.innerHTML = `
                <strong>Network Stats:</strong><br>
                üìç Nodes: ${visibleNodes}/${graph.order}<br>
                üîó Edges: ${visibleEdges}/${graph.size}
            `;
        }
        
        // Start initialization when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
