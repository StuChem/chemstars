<!DOCTYPE html>
<html>
<head>
    <title>Startup Network Viewer</title>
    <meta charset="utf-8">
    <style>
        body { 
            margin: 0; 
            padding: 0; 
            font-family: Arial, sans-serif; 
            background-color: #f5f5f5;
        }
        
        #header {
            background-color: #2c3e50;
            color: white;
            padding: 15px 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        #header h1 {
            margin: 0;
            font-size: 24px;
        }
        
        #controls {
            position: absolute;
            top: 80px;
            left: 20px;
            z-index: 1000;
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-width: 250px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
        }
        
        #controls h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
            color: #2c3e50;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #34495e;
            font-size: 13px;
        }
        
        button {
            background-color: #34495e;
            color: white;
            border: none;
            padding: 8px 15px;
            margin: 2px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }
        
        button:hover {
            background-color: #2c3e50;
        }
        
        button:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
        }
        
        .btn-primary {
            background-color: #3498db;
        }
        
        .btn-primary:hover {
            background-color: #2980b9;
        }
        
        .btn-success {
            background-color: #27ae60;
        }
        
        .btn-success:hover {
            background-color: #229954;
        }
        
        .btn-small {
            font-size: 11px;
            padding: 5px 10px;
        }
        
        .filter-section {
            margin-bottom: 10px;
            padding: 8px;
            background-color: #f8f9fa;
            border-radius: 4px;
            border: 1px solid #e9ecef;
        }
        
        .filter-section label {
            font-size: 11px;
            margin-bottom: 5px;
        }
        
        .checkbox-label {
            font-size: 11px;
            display: flex;
            align-items: center;
            gap: 5px;
            margin-bottom: 3px;
            font-weight: normal;
        }
        
        .submenu {
            margin-left: 20px;
            margin-top: 5px;
            padding-left: 10px;
            border-left: 2px solid #e9ecef;
            display: none;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .submenu.active {
            display: block;
        }
        
        .value-checkbox {
            font-size: 10px;
            margin: 2px 0;
        }
        
        .geography-btn {
            padding: 6px 10px;
            font-size: 10px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            background: #ecf0f1;
            color: #2c3e50;
            transition: background 0.2s;
        }
        
        .geography-btn:hover {
            background: #bdc3c7;
        }
        
        .geography-btn.active {
            background: #3498db;
            color: white;
        }
        
        #legend {
            position: absolute;
            top: 80px;
            right: 20px;
            z-index: 1000;
            background-color: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            min-width: 200px;
            max-width: 300px;
            max-height: calc(100vh - 120px);
            overflow-y: auto;
        }
        
        #legend h3 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #2c3e50;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
            font-size: 11px;
        }
        
        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        
        .legend-label {
            color: #34495e;
        }
        
        input[type="range"] {
            width: 100%;
        }
        
        input[type="text"] {
            width: 100%;
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 3px;
            font-size: 12px;
        }
        
        #sigma-container {
            width: 100%;
            height: calc(100vh - 60px);
            background-color: #ffffff;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            color: #7f8c8d;
            font-size: 18px;
            z-index: 500;
        }
        
        #stats {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: white;
            padding: 10px 15px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            font-size: 12px;
            color: #7f8c8d;
        }
        
        .hidden {
            display: none;
        }
        
        #layout-controls {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }
    </style>
</head>
<body>
    <div id="header">
        <h1>üåê Startup Network Viewer</h1>
    </div>
    
    <div id="loading">
        <div>üìä Loading network data...</div>
        <div style="margin-top: 10px; font-size: 14px;">Please wait while we build the graph</div>
    </div>
    
    <div id="controls" class="hidden">
        <h3>üéõÔ∏è Controls</h3>
        
        <div class="control-group">
            <label>Layout:</label>
            <div id="layout-controls">
                <button onclick="runForceAtlas2()" class="btn-primary btn-small" id="layout-btn">‚ñ∂Ô∏è Run Layout</button>
                <button onclick="stopLayout()" class="btn-small" id="stop-btn" disabled>‚è∏Ô∏è Stop</button>
                <button onclick="resetPositions()" class="btn-small">üîÑ Reset Positions</button>
            </div>
            <div style="margin-top: 5px; font-size: 10px; color: #7f8c8d;">
                <span id="layout-status">Ready</span>
            </div>
        </div>
        
        <div class="control-group">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <label>Layout Settings:</label>
                <button onclick="toggleAdvancedSettings()" style="padding: 4px 8px; font-size: 10px; cursor: pointer; background: #3498db; color: white; border: none; border-radius: 4px;">Advanced ‚öôÔ∏è</button>
            </div>
            
            <div id="advanced-settings" class="hidden">
            
            <div style="margin-bottom: 8px;">
                <label style="font-size: 11px;">Gravity:</label>
                <input type="number" id="gravity" min="0.01" max="2" step="0.01" value="2" style="width: 100%; padding: 4px;" oninput="updateLayoutSettingDisplay()">
            </div>
            
            <div style="margin-bottom: 8px;">
                <label style="font-size: 11px;">Scaling Ratio (Repulsion):</label>
                <input type="number" id="scaling-ratio" min="1" max="50" step="1" value="10" style="width: 100%; padding: 4px;" oninput="updateLayoutSettingDisplay()">
            </div>
            
            <div style="margin-bottom: 8px;">
                <label class="checkbox-label">
                    <input type="checkbox" id="barnes-hut" checked> Barnes-Hut Optimization
                </label>
            </div>
            
            <div style="margin-bottom: 8px;">
                <label class="checkbox-label">
                    <input type="checkbox" id="strong-gravity" checked> Strong Gravity Mode
                </label>
            </div>
            
            <div style="margin-bottom: 8px;">
                <label class="checkbox-label">
                    <input type="checkbox" id="lin-log-mode"> LinLog Mode
                </label>
            </div>
            
            </div>
        </div>
        
        <div class="control-group">
            <label>Node Size:</label>
            <input type="range" id="node-size" min="1" max="10" value="3" oninput="updateNodeSize(this.value)">
            <span id="node-size-value">3</span>
        </div>
        
        <div class="control-group">
            <label>Edge Thickness:</label>
            <input type="range" id="edge-size" min="0.5" max="3" step="0.5" value="1" oninput="updateEdgeSize(this.value)">
            <span id="edge-size-value">1</span>
        </div>
        
        <div class="control-group">
            <label>Display:</label>
            <button onclick="toggleLabels()" id="labels-toggle">üè∑Ô∏è Hide Labels</button>
        </div>
        
        <div class="control-group">
            <label>üé® Node Geography:</label>
            <div style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 5px;">
                <button onclick="toggleNodeGeography('country')" id="node-country-btn" class="geography-btn">üåç Color by Country</button>
                <button onclick="toggleNodeGeography('region')" id="node-region-btn" class="geography-btn">üó∫Ô∏è Color by Region</button>
                <button onclick="toggleNodeGeography('city')" id="node-city-btn" class="geography-btn">üèôÔ∏è Color by City</button>
                <button onclick="resetNodeColors()" class="geography-btn" style="background: #95a5a6;">üîÑ Reset</button>
            </div>
        </div>
        
        <div class="control-group">
            <label>üîç Filters:</label>
            <div style="font-size: 10px; color: #7f8c8d; margin-bottom: 8px; font-style: italic;">AND between categories, OR within each category</div>
            
            <div class="filter-section">
                <label>Connection Types: <span style="font-size: 9px; color: #95a5a6;">(check any values to filter)</span></label>
                <div>
                    <label class="checkbox-label">
                        <input type="checkbox" id="filter-competency" onchange="toggleConnectionType('competency')"> Competencies
                    </label>
                    <div id="submenu-competency" class="submenu"></div>
                    
                    <label class="checkbox-label">
                        <input type="checkbox" id="filter-technical_competency" onchange="toggleConnectionType('technical_competency')"> Technical Competencies
                    </label>
                    <div id="submenu-technical_competency" class="submenu"></div>
                    
                    <label class="checkbox-label">
                        <input type="checkbox" id="filter-impact" onchange="toggleConnectionType('impact')"> Impact
                    </label>
                    <div id="submenu-impact" class="submenu"></div>
                    
                    <label class="checkbox-label">
                        <input type="checkbox" id="filter-city" onchange="toggleConnectionType('city')"> Cities
                    </label>
                    <div id="submenu-city" class="submenu"></div>
                    
                    <label class="checkbox-label">
                        <input type="checkbox" id="filter-country" onchange="toggleConnectionType('country')"> Countries
                    </label>
                    <div id="submenu-country" class="submenu"></div>
                    
                    <label class="checkbox-label">
                        <input type="checkbox" id="filter-region" onchange="toggleConnectionType('region')"> Regions
                    </label>
                    <div id="submenu-region" class="submenu"></div>
                    
                    <label class="checkbox-label">
                        <input type="checkbox" id="filter-cohort" onchange="toggleConnectionType('cohort')"> Cohorts
                    </label>
                    <div id="submenu-cohort" class="submenu"></div>
                </div>
            </div>
            
            <div class="filter-section">
                <label>Node Display:</label>
                <label class="checkbox-label">
                    <input type="checkbox" id="show-all-nodes" checked onchange="updateFilters()"> Show All Nodes
                </label>
                <div style="font-size: 9px; color: #7f8c8d; margin-top: 3px;">
                    When unchecked, only shows nodes with visible connections
                </div>
            </div>
            
            <div class="filter-section">
                <label>Edge Weight:</label>
                <div style="display: flex; gap: 5px; align-items: center; font-size: 11px;">
                    <span>Min:</span>
                    <input type="range" id="weight-min" min="1" max="20" value="1" style="width: 60px;" oninput="updateFilters()">
                    <span id="weight-min-value">1</span>
                    <span>Max:</span>
                    <input type="range" id="weight-max" min="1" max="20" value="20" style="width: 60px;" oninput="updateFilters()">
                    <span id="weight-max-value">20</span>
                </div>
            </div>
            
            <div class="filter-section">
                <label>Search Nodes:</label>
                <input type="text" id="search-nodes" placeholder="Type to search..." oninput="updateFilters()">
            </div>
            
            <button onclick="clearAllFilters()" class="btn-small">Clear All Filters</button>
        </div>
    </div>
    
    <div id="sigma-container"></div>
    
    <div id="stats" class="hidden">
        <div id="graph-stats"></div>
    </div>
    
            <div id="legend" class="hidden">
                <h3>üé® Edge Filter Legend</h3>
                <div id="legend-content"></div>
            </div>    <!-- Include graphology and sigma.js from CDN -->
    <script src="https://cdn.jsdelivr.net/npm/graphology@0.25.4/dist/graphology.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sigma@2.4.0/build/sigma.min.js"></script>
    <script type="module">
        import forceAtlas2 from 'https://cdn.jsdelivr.net/npm/graphology-layout-forceatlas2@0.10.1/+esm';
        window.forceAtlas2 = forceAtlas2;
    </script>
    
    <script>
        let sigmaInstance = null;
        let graph = null;
        let showLabels = true;
        let layoutWorker = null;
        let layoutRunning = false;
        let originalNodeColors = new Map();
        let originalEdgeColors = new Map();
        let originalEdgeSizes = new Map();
        let nodeGeographyMode = null; // 'country', 'region', 'city', or null for no geography coloring
        let activeFilters = {
            types: [],
            values: {}, // e.g., { competency: ['Hydrogen', 'Battery'], region: ['Berlin'] }
            weightMin: 1,
            weightMax: 20,
            searchText: '',
            showAllNodes: true
        };
        
        // High-contrast color palette for dynamic assignment
        // Colors are assigned in order as checkboxes are checked
        const diversePalette = [
            '#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6',
            '#1abc9c', '#e67e22', '#34495e', '#e91e63', '#00bcd4',
            '#ff5722', '#8bc34a', '#673ab7', '#ff9800', '#009688',
            '#795548', '#607d8b', '#ffc107', '#cddc39', '#03a9f4'
        ];
        let nextColorIndex = 0; // Track next color to assign
        
        // Track available values for each connection type
        let availableValues = {
            competency: new Set(),
            technical_competency: new Set(),
            impact: new Set(),
            city: new Set(),
            country: new Set(),
            region: new Set(),
            cohort: new Set()
        };
        
        // Color assignments for specific values
        let valueColors = {};
        
        // Initialize by loading the JSON data
        async function init() {
            try {
                console.log('Loading network data...');
                const response = await fetch('network_data.json?v=' + Date.now());
                const data = await response.json();
                
                console.log(`Loaded ${data.nodes.length} nodes and ${data.edges.length} edges`);
                
                // Create graph using graphology (accessing from global)
                const Graph = graphology.Graph;
                graph = new Graph({ type: 'undirected' });
                
                // Add nodes
                data.nodes.forEach(node => {
                    const nodeColor = '#95a5a6';
                    graph.addNode(node.id, {
                        label: node.label,
                        x: Math.random() * 100,
                        y: Math.random() * 100,
                        size: 3,
                        color: nodeColor,
                        description: node.description || '',
                        website: node.website || '',
                        logo_url: node.logo_url || ''
                    });
                    originalNodeColors.set(node.id, nodeColor);
                });
                
                // Add edges
                console.log('Sample edge from JSON:', data.edges.find(e => e.technical_competencies?.length > 0));
                data.edges.forEach(edge => {
                    try {
                        const edgeAttrs = {
                            weight: edge.weight,
                            size: Math.min(3, edge.weight * 0.3),
                            color: '#bdc3c7',
                            label: edge.label_detailed || edge.label,
                            types: edge.types || [],
                            is_competency: edge.is_competency || false,
                            is_technical_competency: edge.is_technical_competency || false,
                            is_impact: edge.is_impact || false,
                            is_city: edge.is_city || false,
                            is_country: edge.is_country || false,
                            is_region: edge.is_region || false,
                            is_cohort: edge.is_cohort || false,
                            competencies: edge.competencies || [],
                            technical_competencies: edge.technical_competencies || [],
                            impacts: edge.impacts || [],
                            cities: edge.cities || [],
                            countries: edge.countries || [],
                            regions: edge.regions || [],
                            cohorts: edge.cohorts || []
                        };
                        
                        graph.addEdge(edge.source, edge.target, edgeAttrs);
                        
                        // Store original color and size for hover interactions
                        const edgeKey = graph.edge(edge.source, edge.target);
                        originalEdgeColors.set(edgeKey, '#bdc3c7');
                        originalEdgeSizes.set(edgeKey, edgeAttrs.size);
                    } catch (e) {
                        // Edge might already exist, skip
                        console.warn(`Skipping duplicate edge: ${edge.source} - ${edge.target}`);
                    }
                });
                
                console.log(`Graph built: ${graph.order} nodes, ${graph.size} edges`);
                
                // Create sigma instance (check if Sigma exists in global scope)
                if (typeof Sigma === 'undefined') {
                    throw new Error('Sigma is not defined - library did not load correctly');
                }
                
                sigmaInstance = new Sigma(graph, document.getElementById('sigma-container'), {
                    renderLabels: showLabels,
                    renderEdgeLabels: false,
                    labelFont: 'Arial',
                    labelSize: 12,
                    labelWeight: 'normal',
                    minCameraRatio: 0.1,
                    maxCameraRatio: 10,
                    enableEdgeHoverEvents: true,
                    enableEdgeClickEvents: true
                });
                
                // Setup interactions
                setupHoverInteractions();
                
                // Collect available values and build submenus
                collectAvailableValues();
                buildValueSubmenus();
                
                document.getElementById('loading').classList.add('hidden');
                document.getElementById('controls').classList.remove('hidden');
                document.getElementById('stats').classList.remove('hidden');
                document.getElementById('legend').classList.remove('hidden');
                
                updateStats();
                updateLegend();
                
                console.log('‚úÖ Initialization complete');
                
            } catch (error) {
                console.error('Error loading data:', error);
                document.getElementById('loading').innerHTML = 
                    `<div style="color: #e74c3c;">‚ùå Error loading network data</div>
                     <div style="font-size: 14px; margin-top: 10px;">${error.message}</div>`;
            }
        }
        
        function collectAvailableValues() {
            // Scan all edges to find unique values for each connection type
            graph.forEachEdge((edge, attributes) => {
                if (attributes.competencies) {
                    attributes.competencies.forEach(val => availableValues.competency.add(val));
                }
                if (attributes.technical_competencies) {
                    attributes.technical_competencies.forEach(val => availableValues.technical_competency.add(val));
                }
                if (attributes.impacts) {
                    attributes.impacts.forEach(val => availableValues.impact.add(val));
                }
                if (attributes.cities) {
                    attributes.cities.forEach(val => availableValues.city.add(val));
                }
                if (attributes.countries) {
                    attributes.countries.forEach(val => availableValues.country.add(val));
                }
                if (attributes.regions) {
                    attributes.regions.forEach(val => availableValues.region.add(val));
                }
                if (attributes.cohorts) {
                    attributes.cohorts.forEach(val => availableValues.cohort.add(val));
                }
            });
            
            console.log('Available values collected:', {
                competencies: availableValues.competency.size,
                technical_competencies: availableValues.technical_competency.size,
                impacts: availableValues.impact.size,
                cities: availableValues.city.size,
                countries: availableValues.country.size,
                regions: availableValues.region.size,
                cohorts: availableValues.cohort.size
            });
        }
        
        function buildValueSubmenus() {
            const types = ['competency', 'technical_competency', 'impact', 'city', 'country', 'region', 'cohort'];
            
            types.forEach(type => {
                const submenu = document.getElementById(`submenu-${type}`);
                // Sort cohorts numerically, others alphabetically
                let values;
                if (type === 'cohort') {
                    values = Array.from(availableValues[type]).sort((a, b) => {
                        const numA = parseInt(a.match(/\d+/)?.[0] || '0');
                        const numB = parseInt(b.match(/\d+/)?.[0] || '0');
                        return numA - numB;
                    });
                } else {
                    values = Array.from(availableValues[type]).sort();
                }
                
                if (values.length === 0) {
                    submenu.innerHTML = '<div style="font-size: 10px; color: #95a5a6; padding: 5px;">No values found</div>';
                    return;
                }
                
                // Add "Select All" button
                const selectAllBtn = document.createElement('button');
                selectAllBtn.textContent = 'Select All';
                selectAllBtn.className = 'select-all-btn';
                selectAllBtn.style.cssText = 'width: 100%; padding: 5px; margin-bottom: 8px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 11px;';
                selectAllBtn.onmouseover = function() { this.style.background = '#2980b9'; };
                selectAllBtn.onmouseout = function() { this.style.background = '#3498db'; };
                selectAllBtn.onclick = function() { selectAllValues(type); };
                submenu.appendChild(selectAllBtn);
                
                values.forEach(value => {
                    const label = document.createElement('label');
                    label.className = 'checkbox-label value-checkbox';
                    label.innerHTML = `
                        <input type="checkbox" 
                               data-type="${type}" 
                               data-value="${value}" 
                               onchange="updateValueFilter('${type}', '${value}', this.checked)">
                        ${value}
                    `;
                    submenu.appendChild(label);
                });
            });
        }
        
        function assignColorToValue(type, value) {
            // Assign next available color from diverse palette
            if (!valueColors[type]) valueColors[type] = {};
            if (!valueColors[type][value]) {
                valueColors[type][value] = diversePalette[nextColorIndex % diversePalette.length];
                nextColorIndex++;
            }
            return valueColors[type][value];
        }
        
        function toggleConnectionType(type) {
            const checkbox = document.getElementById(`filter-${type}`);
            const submenu = document.getElementById(`submenu-${type}`);
            
            if (checkbox.checked) {
                submenu.classList.add('active');
            } else {
                submenu.classList.remove('active');
                // Uncheck all value checkboxes
                const valueCheckboxes = submenu.querySelectorAll('input[type="checkbox"]');
                valueCheckboxes.forEach(cb => {
                    cb.checked = false;
                });
                // Clear this type from active filters
                if (activeFilters.values[type]) {
                    delete activeFilters.values[type];
                }
            }
            
            updateFilters();
        }
        
        function updateValueFilter(type, value, checked) {
            if (!activeFilters.values[type]) {
                activeFilters.values[type] = [];
            }
            
            if (checked) {
                if (!activeFilters.values[type].includes(value)) {
                    activeFilters.values[type].push(value);
                    // Assign color when checkbox is first checked
                    assignColorToValue(type, value);
                }
            } else {
                activeFilters.values[type] = activeFilters.values[type].filter(v => v !== value);
                if (activeFilters.values[type].length === 0) {
                    delete activeFilters.values[type];
                }
            }
            
            updateFilters();
        }
        
        function selectAllValues(type) {
            const submenu = document.getElementById(`submenu-${type}`);
            const checkboxes = submenu.querySelectorAll('input[type="checkbox"][data-type="' + type + '"]');
            
            // Check all checkboxes
            checkboxes.forEach(cb => {
                if (!cb.checked) {
                    cb.checked = true;
                    const value = cb.getAttribute('data-value');
                    if (!activeFilters.values[type]) {
                        activeFilters.values[type] = [];
                    }
                    if (!activeFilters.values[type].includes(value)) {
                        activeFilters.values[type].push(value);
                        assignColorToValue(type, value);
                    }
                }
            });
            
            updateFilters();
        }
        
        function updateLegend() {
            const legendContent = document.getElementById('legend-content');
            legendContent.innerHTML = '';
            
            let hasItems = false;
            
            // Show node geography colors if active
            if (nodeGeographyMode) {
                const geoHeader = document.createElement('div');
                geoHeader.style.fontWeight = 'bold';
                geoHeader.style.fontSize = '12px';
                geoHeader.style.marginBottom = '8px';
                geoHeader.style.color = '#2c3e50';
                geoHeader.innerHTML = `üìç Node Colors (${nodeGeographyMode.charAt(0).toUpperCase() + nodeGeographyMode.slice(1)})`;
                legendContent.appendChild(geoHeader);
                
                // Collect unique geographic values and their colors
                const geoValues = new Set();
                const geoValueColors = {};
                
                graph.forEachEdge((edge, attributes) => {
                    let edgeGeoValues = [];
                    if (nodeGeographyMode === 'country' && attributes.countries) {
                        edgeGeoValues = attributes.countries;
                    } else if (nodeGeographyMode === 'region' && attributes.regions) {
                        edgeGeoValues = attributes.regions;
                    } else if (nodeGeographyMode === 'city' && attributes.cities) {
                        edgeGeoValues = attributes.cities;
                    }
                    
                    edgeGeoValues.forEach(geoValue => {
                        geoValues.add(geoValue);
                    });
                });
                
                // Assign colors (same logic as applyNodeGeographyColoring)
                Array.from(geoValues).sort().forEach((value, index) => {
                    geoValueColors[value] = diversePalette[index % diversePalette.length];
                });
                
                // Display legend items
                Object.entries(geoValueColors).forEach(([value, color]) => {
                    const item = document.createElement('div');
                    item.className = 'legend-item';
                    item.style.display = 'flex';
                    item.style.alignItems = 'center';
                    item.style.gap = '6px';
                    item.style.marginLeft = '8px';
                    
                    const colorBox = document.createElement('div');
                    colorBox.style.width = '20px';
                    colorBox.style.height = '20px';
                    colorBox.style.backgroundColor = color;
                    colorBox.style.border = '1px solid #ccc';
                    colorBox.style.borderRadius = '3px';
                    
                    const label = document.createElement('span');
                    label.className = 'legend-label';
                    label.textContent = value;
                    label.style.flex = '1';
                    
                    item.appendChild(colorBox);
                    item.appendChild(label);
                    legendContent.appendChild(item);
                });
                
                hasItems = true;
            }
            
            const allTypes = ['competency', 'technical_competency', 'impact', 'city', 'country', 'region', 'cohort'];
            const typeLabels = {
                competency: 'Competencies',
                technical_competency: 'Technical Competencies',
                impact: 'Impact',
                city: 'Cities',
                country: 'Countries',
                region: 'Regions',
                cohort: 'Cohorts'
            };
            
            // Show all active edge filters with their colors
            allTypes.forEach(type => {
                if (activeFilters.values[type] && activeFilters.values[type].length > 0) {
                    const header = document.createElement('div');
                    header.style.fontWeight = 'bold';
                    header.style.fontSize = '12px';
                    header.style.marginTop = hasItems ? '12px' : '0';
                    header.style.marginBottom = '6px';
                    header.style.color = '#2c3e50';
                    header.innerHTML = `üîó ${typeLabels[type]} (Edges)`;
                    legendContent.appendChild(header);
                    
                    activeFilters.values[type].forEach(value => {
                        const item = document.createElement('div');
                        item.className = 'legend-item';
                        item.style.display = 'flex';
                        item.style.alignItems = 'center';
                        item.style.gap = '6px';
                        item.style.marginLeft = '8px';
                        
                        const colorPicker = document.createElement('input');
                        colorPicker.type = 'color';
                        colorPicker.value = valueColors[type][value];
                        colorPicker.style.width = '20px';
                        colorPicker.style.height = '20px';
                        colorPicker.style.border = 'none';
                        colorPicker.style.cursor = 'pointer';
                        colorPicker.style.padding = '0';
                        colorPicker.title = 'Click to change edge color';
                        colorPicker.addEventListener('change', (e) => {
                            valueColors[type][value] = e.target.value;
                            applyFilters();
                        });
                        
                        const label = document.createElement('span');
                        label.className = 'legend-label';
                        label.textContent = value;
                        label.style.flex = '1';
                        
                        item.appendChild(colorPicker);
                        item.appendChild(label);
                        legendContent.appendChild(item);
                    });
                    
                    hasItems = true;
                }
            });
            
            if (!hasItems) {
                legendContent.innerHTML = '<div style="font-size: 11px; color: #95a5a6;">Select filters or geography to see legend</div>';
            }
        }
        
        function runForceAtlas2() {
            if (!graph || layoutRunning) return;
            
            console.log('Starting Force Atlas 2 layout...');
            
            if (typeof window.forceAtlas2 === 'undefined') {
                console.error('Force Atlas 2 library not loaded');
                document.getElementById('layout-status').textContent = 'Error: Layout library not loaded';
                return;
            }
            
            layoutRunning = true;
            document.getElementById('layout-btn').disabled = true;
            document.getElementById('stop-btn').disabled = false;
            document.getElementById('layout-status').textContent = 'Running...';
            
            // Get settings from UI controls
            const settings = {
                barnesHutOptimize: document.getElementById('barnes-hut').checked,
                strongGravityMode: document.getElementById('strong-gravity').checked,
                gravity: parseFloat(document.getElementById('gravity').value),
                scalingRatio: parseFloat(document.getElementById('scaling-ratio').value),
                slowDown: 5,
                edgeWeightInfluence: 1,
                linLogMode: document.getElementById('lin-log-mode').checked
            };
            
            console.log('Layout settings:', settings);
            
            // Create a filtered graph that only contains visible edges
            const Graph = graphology.Graph;
            const filteredGraph = new Graph({ type: 'undirected' });
            
            // Add all nodes with their positions
            graph.forEachNode((node, attributes) => {
                filteredGraph.addNode(node, attributes);
            });
            
            // Only add visible edges
            let visibleEdgeCount = 0;
            graph.forEachEdge((edge, attributes, source, target) => {
                if (!attributes.hidden) {
                    try {
                        filteredGraph.addEdge(source, target, attributes);
                        visibleEdgeCount++;
                    } catch (e) {
                        // Edge might already exist, skip
                    }
                }
            });
            
            console.log(`Running layout on ${filteredGraph.order} nodes and ${visibleEdgeCount} visible edges`);
            
            if (visibleEdgeCount === 0) {
                console.warn('No visible edges to layout');
                document.getElementById('layout-status').textContent = 'No edges to layout';
                stopLayout();
                return;
            }
            
            let iteration = 0;
            const maxIterations = 300;
            
            layoutWorker = setInterval(() => {
                if (iteration >= maxIterations) {
                    stopLayout();
                    return;
                }
                
                // Run layout on filtered graph
                window.forceAtlas2.assign(filteredGraph, { iterations: 1, settings: settings });
                
                // Copy positions back to original graph
                filteredGraph.forEachNode((node, attributes) => {
                    graph.setNodeAttribute(node, 'x', attributes.x);
                    graph.setNodeAttribute(node, 'y', attributes.y);
                });
                
                sigmaInstance.refresh();
                iteration++;
                
                if (iteration % 10 === 0) {
                    document.getElementById('layout-status').textContent = 
                        `Running... ${Math.round((iteration / maxIterations) * 100)}%`;
                }
            }, 10);
        }
        
        function updateLayoutSettingDisplay() {
            // No display updates needed for number inputs
        }
        
        function stopLayout() {
            if (layoutWorker) {
                clearInterval(layoutWorker);
                layoutWorker = null;
            }
            layoutRunning = false;
            document.getElementById('layout-btn').disabled = false;
            document.getElementById('stop-btn').disabled = true;
            document.getElementById('layout-status').textContent = 'Ready';
            console.log('Layout stopped');
        }
        
        function resetPositions() {
            if (!graph) return;
            
            stopLayout();
            
            // Randomize positions
            graph.forEachNode((node) => {
                graph.setNodeAttribute(node, 'x', Math.random() * 100);
                graph.setNodeAttribute(node, 'y', Math.random() * 100);
            });
            
            sigmaInstance.refresh();
            resetView();
        }
        
        function setupHoverInteractions() {
            if (!sigmaInstance) return;
            
            let hoveredNode = null;
            let hoveredEdge = null;
            
            // Node hover events
            sigmaInstance.on('enterNode', (event) => {
                hoveredNode = event.node;
                const nodeAttributes = graph.getNodeAttributes(event.node);
                
                // Show labels on connected nodes
                graph.forEachEdge((edge, attributes) => {
                    const [source, target] = graph.extremities(edge);
                    if ((source === event.node || target === event.node) && !attributes.hidden) {
                        const connectedNode = source === event.node ? target : source;
                        const connectedAttrs = graph.getNodeAttributes(connectedNode);
                        
                        // Create floating label for connected node
                        const nodePos = sigmaInstance.getNodeDisplayData(connectedNode);
                        if (nodePos) {
                            const label = document.createElement('div');
                            label.className = 'connected-node-label';
                            label.style.position = 'absolute';
                            label.style.left = (nodePos.x + 10) + 'px';
                            label.style.top = (nodePos.y - 10) + 'px';
                            label.style.background = 'rgba(0,0,0,0.8)';
                            label.style.color = 'white';
                            label.style.padding = '4px 6px';
                            label.style.borderRadius = '3px';
                            label.style.fontSize = '11px';
                            label.style.pointerEvents = 'none';
                            label.style.zIndex = '9999';
                            label.style.whiteSpace = 'nowrap';
                            label.textContent = connectedAttrs.label || connectedNode;
                            label.id = `label-${connectedNode}`;
                            document.body.appendChild(label);
                        }
                        
                        // Highlight connected edges
                        const originalSize = originalEdgeSizes.get(edge) || 1;
                        graph.setEdgeAttribute(edge, 'color', '#ff6b6b');
                        graph.setEdgeAttribute(edge, 'size', originalSize * 2);
                    }
                });
                
                // Show comprehensive tooltip with persistent positioning
                showDetailedTooltip(event.event.x, event.event.y, {
                    title: nodeAttributes.label || event.node,
                    type: 'node',
                    attributes: nodeAttributes,
                    nodeId: event.node
                });
                
                sigmaInstance.refresh();
            });
            
            sigmaInstance.on('leaveNode', (event) => {
                if (hoveredNode === event.node) {
                    hoveredNode = null;
                    
                    // Remove connected node labels
                    document.querySelectorAll('.connected-node-label').forEach(label => {
                        label.remove();
                    });
                    
                    // Auto-hide tooltip with delay to allow moving to tooltip
                    const tooltip = document.getElementById('detailed-tooltip');
                    if (tooltip) {
                        setTimeout(() => {
                            if (!hoveredNode && tooltip.dataset.hovering !== 'true') {
                                tooltip.style.display = 'none';
                            }
                        }, 100);
                    }
                    
                    // Reapply filters to restore the correct filtered colors and sizes
                    applyFilters();
                }
            });
            
            sigmaInstance.on('clickNode', (event) => {
                const nodeData = graph.getNodeAttributes(event.node);
                console.log('Clicked node:', event.node, nodeData);
                
                if (nodeData.website) {
                    window.open(nodeData.website, '_blank');
                }
            });
            
            // Edge hover events
            sigmaInstance.on('enterEdge', (event) => {
                console.log('enterEdge fired:', event);
                const edge = event.edge;
                const edgeAttributes = graph.getEdgeAttributes(edge);
                console.log('Edge attributes:', edgeAttributes);
                if (edgeAttributes.hidden) return;
                
                hoveredEdge = edge;
                
                const [source, target] = graph.extremities(edge);
                const sourceAttrs = graph.getNodeAttributes(source);
                const targetAttrs = graph.getNodeAttributes(target);
                
                // Highlight the edge - make it red and 3x bigger
                const originalSize = originalEdgeSizes.get(edge) || 1;
                graph.setEdgeAttribute(edge, 'color', '#e74c3c');
                graph.setEdgeAttribute(edge, 'size', originalSize * 3);
                sigmaInstance.refresh();
                
                // Build tooltip content
                let tooltipHTML = `<strong>${sourceAttrs.label}</strong> ‚Üî <strong>${targetAttrs.label}</strong><br><br>`;
                tooltipHTML += `<strong>Shared Connections (${edgeAttributes.weight}):</strong><br>`;
                
                const connections = [];
                console.log('Building connections from attributes:', {
                    technical_competencies: edgeAttributes.technical_competencies,
                    cohorts: edgeAttributes.cohorts
                });
                if (edgeAttributes.competencies && edgeAttributes.competencies.length > 0) {
                    connections.push(`<span style="color: #f39c12;">‚óè</span> <strong>Competencies:</strong> ${edgeAttributes.competencies.join(', ')}`);
                }
                if (edgeAttributes.technical_competencies && edgeAttributes.technical_competencies.length > 0) {
                    connections.push(`<span style="color: #e67e22;">‚óè</span> <strong>Technical Competencies:</strong> ${edgeAttributes.technical_competencies.join(', ')}`);
                }
                if (edgeAttributes.impacts && edgeAttributes.impacts.length > 0) {
                    connections.push(`<span style="color: #9b59b6;">‚óè</span> <strong>Impacts:</strong> ${edgeAttributes.impacts.join(', ')}`);
                }
                if (edgeAttributes.cities && edgeAttributes.cities.length > 0) {
                    connections.push(`<span style="color: #e74c3c;">‚óè</span> <strong>Cities:</strong> ${edgeAttributes.cities.join(', ')}`);
                }
                if (edgeAttributes.countries && edgeAttributes.countries.length > 0) {
                    connections.push(`<span style="color: #2ecc71;">‚óè</span> <strong>Countries:</strong> ${edgeAttributes.countries.join(', ')}`);
                }
                if (edgeAttributes.regions && edgeAttributes.regions.length > 0) {
                    connections.push(`<span style="color: #3498db;">‚óè</span> <strong>Regions:</strong> ${edgeAttributes.regions.join(', ')}`);
                }
                if (edgeAttributes.cohorts && edgeAttributes.cohorts.length > 0) {
                    connections.push(`<span style="color: #1abc9c;">‚óè</span> <strong>Cohorts:</strong> ${edgeAttributes.cohorts.join(', ')}`);
                }
                
                tooltipHTML += connections.join('<br>');
                
                // Show tooltip
                showHoverTooltip(event.event.x, event.event.y, {
                    title: tooltipHTML,
                    type: 'edge',
                    attributes: edgeAttributes,
                    source: source,
                    target: target,
                    isHTML: true
                });
            });
            
            sigmaInstance.on('leaveEdge', (event) => {
                const edge = event.edge;
                if (hoveredEdge === edge) {
                    hoveredEdge = null;
                    hideHoverTooltip();
                    
                    // Reapply filters to restore the correct filtered colors and sizes
                    applyFilters();
                }
            });
        }
        
        function showDetailedTooltip(x, y, data) {
            let tooltip = document.getElementById('detailed-tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'detailed-tooltip';
                tooltip.style.position = 'fixed';
                tooltip.style.background = 'rgba(255,255,255,0.98)';
                tooltip.style.color = '#2c3e50';
                tooltip.style.padding = '16px';
                tooltip.style.borderRadius = '8px';
                tooltip.style.fontSize = '13px';
                tooltip.style.zIndex = '10001';
                tooltip.style.maxWidth = '400px';
                tooltip.style.maxHeight = '500px';
                tooltip.style.overflowY = 'auto';
                tooltip.style.lineHeight = '1.5';
                tooltip.style.boxShadow = '0 8px 32px rgba(0,0,0,0.2)';
                tooltip.style.border = '1px solid #e1e8ed';
                tooltip.style.pointerEvents = 'auto';
                tooltip.style.cursor = 'default';
                
                // Add mouse event handlers for auto-hide functionality
                tooltip.onmouseenter = () => {
                    tooltip.dataset.hovering = 'true';
                };
                tooltip.onmouseleave = () => {
                    tooltip.dataset.hovering = 'false';
                    // Small delay to allow moving between node and tooltip
                    setTimeout(() => {
                        if (tooltip.dataset.hovering === 'false' && !hoveredNode) {
                            tooltip.style.display = 'none';
                            document.querySelectorAll('.connected-node-label').forEach(label => label.remove());
                        }
                    }, 100);
                };
                
                document.body.appendChild(tooltip);
            }
            
            if (data.type === 'node' && data.attributes) {
                let html = `<div style="padding-right: 24px;"><strong style="font-size: 16px; color: #2c3e50;">${data.title}</strong></div><br>`;
                
                // Collect all node information from edges
                const nodeInfo = {
                    competencies: new Set(),
                    technical_competencies: new Set(),
                    impacts: new Set(),
                    cities: new Set(),
                    countries: new Set(),
                    regions: new Set(),
                    cohorts: new Set()
                };
                
                // Find this node's information from edges
                graph.forEachEdge((edge, attributes) => {
                    const [source, target] = graph.extremities(edge);
                    if (source === data.nodeId || target === data.nodeId) {
                        if (attributes.competencies) attributes.competencies.forEach(c => nodeInfo.competencies.add(c));
                        if (attributes.technical_competencies) attributes.technical_competencies.forEach(c => nodeInfo.technical_competencies.add(c));
                        if (attributes.impacts) attributes.impacts.forEach(i => nodeInfo.impacts.add(i));
                        if (attributes.cities) attributes.cities.forEach(c => nodeInfo.cities.add(c));
                        if (attributes.countries) attributes.countries.forEach(c => nodeInfo.countries.add(c));
                        if (attributes.regions) attributes.regions.forEach(r => nodeInfo.regions.add(r));
                        if (attributes.cohorts) attributes.cohorts.forEach(c => nodeInfo.cohorts.add(c));
                    }
                });
                
                // Show basic attributes
                if (data.attributes.description && data.attributes.description.trim()) {
                    html += `<div style="margin-bottom: 12px;"><strong>Description:</strong><br><div style="background: #f8f9fa; padding: 8px; border-radius: 4px; font-size: 12px;">${data.attributes.description}</div></div>`;
                }
                
                if (data.attributes.website && data.attributes.website.trim()) {
                    html += `<div style="margin-bottom: 12px;"><strong>Website:</strong><br><a href="${data.attributes.website}" target="_blank" style="color: #3498db; text-decoration: none;">${data.attributes.website}</a></div>`;
                }
                
                // Show collected information
                const sections = [
                    { key: 'competencies', label: 'Core Competencies', icon: 'üí°' },
                    { key: 'technical_competencies', label: 'Technical Competencies', icon: 'üîß' },
                    { key: 'impacts', label: 'Impact Areas', icon: 'üéØ' },
                    { key: 'cities', label: 'Cities', icon: 'üèôÔ∏è' },
                    { key: 'countries', label: 'Countries', icon: 'üåç' },
                    { key: 'regions', label: 'Regions', icon: 'üó∫Ô∏è' },
                    { key: 'cohorts', label: 'Cohorts', icon: 'üéì' }
                ];
                
                sections.forEach(section => {
                    const items = Array.from(nodeInfo[section.key]);
                    if (items.length > 0) {
                        html += `<div style="margin-bottom: 12px;">
                            <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 6px;">
                                <strong>${section.icon} ${section.label}:</strong>
                                <button onclick="addAllToFilters('${section.key}', ${JSON.stringify(items).replace(/"/g, '&quot;')})" 
                                        style="background: #3498db; color: white; border: none; padding: 4px 8px; border-radius: 4px; font-size: 10px; cursor: pointer; margin-left: 8px;"
                                        onmouseover="this.style.background='#2980b9'" 
                                        onmouseout="this.style.background='#3498db'">
                                    Add All
                                </button>
                            </div>`;
                        html += `<div style="background: #f8f9fa; padding: 8px; border-radius: 4px; font-size: 12px;">`;
                        items.sort().forEach(item => {
                            html += `<span style="display: inline-block; background: #ecf0f1; padding: 2px 6px; margin: 2px; border-radius: 3px; font-size: 11px;">${item}</span>`;
                        });
                        html += `</div></div>`;
                    }
                });
                
                tooltip.innerHTML = html;
                
                // Add close button again (since innerHTML overwrites)
                const closeBtn = document.createElement('button');
                closeBtn.innerHTML = '√ó';
                closeBtn.style.position = 'absolute';
                closeBtn.style.right = '8px';
                closeBtn.style.top = '8px';
                closeBtn.style.background = 'none';
                closeBtn.style.border = 'none';
                closeBtn.style.fontSize = '18px';
                closeBtn.style.cursor = 'pointer';
                closeBtn.style.color = '#7f8c8d';
                closeBtn.onclick = () => {
                    tooltip.style.display = 'none';
                    document.querySelectorAll('.connected-node-label').forEach(label => label.remove());
                };
                tooltip.appendChild(closeBtn);
            }
            
            // Position tooltip
            tooltip.style.left = Math.min(x + 15, window.innerWidth - 420) + 'px';
            tooltip.style.top = Math.min(y + 15, window.innerHeight - Math.min(500, tooltip.offsetHeight || 300)) + 'px';
            tooltip.style.display = 'block';
        }
        
        function showHoverTooltip(x, y, data) {
            let tooltip = document.getElementById('hover-tooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'hover-tooltip';
                tooltip.style.position = 'absolute';
                tooltip.style.background = 'rgba(0,0,0,0.9)';
                tooltip.style.color = 'white';
                tooltip.style.padding = '12px';
                tooltip.style.borderRadius = '6px';
                tooltip.style.fontSize = '13px';
                tooltip.style.zIndex = '10000';
                tooltip.style.pointerEvents = 'none';
                tooltip.style.maxWidth = '400px';
                tooltip.style.maxHeight = '500px';
                tooltip.style.overflowY = 'auto';
                tooltip.style.lineHeight = '1.4';
                tooltip.style.boxShadow = '0 4px 6px rgba(0,0,0,0.3)';
                document.body.appendChild(tooltip);
            }
            
            let content;
            if (data.isHTML) {
                content = data.title;
            } else if (data.type === 'node' && data.attributes) {
                // Enhanced node tooltip with all attributes
                content = `<strong style="font-size: 14px;">${data.title}</strong><br><br>`;
                
                // Show all node attributes
                if (data.attributes.description) {
                    content += `<div style="margin-bottom: 8px;"><strong>Description:</strong><br>${data.attributes.description}</div>`;
                }
                if (data.attributes.website) {
                    content += `<div style="margin-bottom: 8px;"><strong>Website:</strong><br><a href="${data.attributes.website}" target="_blank" style="color: #3498db;">${data.attributes.website}</a></div>`;
                }
                
                // Show connected companies
                if (data.connectedNodes && data.connectedNodes.length > 0) {
                    content += `<div style="margin-top: 12px; border-top: 1px solid rgba(255,255,255,0.2); padding-top: 8px;">`;
                    content += `<strong>Connected to ${data.connectedNodes.length} companies:</strong><br>`;
                    content += `<div style="margin-top: 6px; font-size: 11px; max-height: 200px; overflow-y: auto;">`;
                    data.connectedNodes.forEach(node => {
                        content += `‚Ä¢ ${node}<br>`;
                    });
                    content += `</div></div>`;
                }
            } else {
                content = `<strong>${data.title}</strong>`;
                if (data.type === 'edge' && data.source && data.target) {
                    content += `<br><small>From: ${data.source}<br>To: ${data.target}</small>`;
                    if (data.attributes && data.attributes.weight) {
                        content += `<br><small>Weight: ${data.attributes.weight}</small>`;
                    }
                }
            }
            
            tooltip.innerHTML = content;
            tooltip.style.left = (x + 15) + 'px';
            tooltip.style.top = (y + 15) + 'px';
            tooltip.style.display = 'block';
        }
        
        function hideHoverTooltip() {
            const tooltip = document.getElementById('hover-tooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }
        
        function zoomIn() {
            if (sigmaInstance) {
                const camera = sigmaInstance.getCamera();
                camera.animatedZoom({ duration: 200 });
            }
        }
        
        function zoomOut() {
            if (sigmaInstance) {
                const camera = sigmaInstance.getCamera();
                camera.animatedUnzoom({ duration: 200 });
            }
        }
        
        function resetView() {
            if (sigmaInstance) {
                const camera = sigmaInstance.getCamera();
                camera.animatedReset({ duration: 500 });
            }
        }
        
        function updateNodeSize(value) {
            document.getElementById('node-size-value').textContent = value;
            if (graph && sigmaInstance) {
                graph.forEachNode((node) => {
                    graph.setNodeAttribute(node, 'size', parseFloat(value));
                });
                sigmaInstance.refresh();
            }
        }
        
        function updateEdgeSize(value) {
            document.getElementById('edge-size-value').textContent = value;
            if (graph && sigmaInstance) {
                graph.forEachEdge((edge, attributes) => {
                    const thickness = Math.max(0.5, attributes.weight * parseFloat(value) * 0.3);
                    graph.setEdgeAttribute(edge, 'size', thickness);
                });
                sigmaInstance.refresh();
            }
        }
        
        function toggleLabels() {
            showLabels = !showLabels;
            if (sigmaInstance) {
                sigmaInstance.setSetting('renderLabels', showLabels);
                sigmaInstance.refresh();
            }
            document.getElementById('labels-toggle').textContent = 
                showLabels ? 'üè∑Ô∏è Hide Labels' : 'üè∑Ô∏è Show Labels';
        }
        
        function toggleAdvancedSettings() {
            const advancedSettings = document.getElementById('advanced-settings');
            advancedSettings.classList.toggle('hidden');
        }
        
        function toggleNodeGeography(geoType) {
            // Toggle the geography mode
            if (nodeGeographyMode === geoType) {
                nodeGeographyMode = null; // Turn off if already active
            } else {
                nodeGeographyMode = geoType; // Set new geography mode
            }
            
            // Update button styles
            ['country', 'region', 'city'].forEach(type => {
                const btn = document.getElementById(`node-${type}-btn`);
                if (type === nodeGeographyMode) {
                    btn.classList.add('active');
                } else {
                    btn.classList.remove('active');
                }
            });
            
            applyNodeGeographyColoring();
        }
        
        function resetNodeColors() {
            nodeGeographyMode = null;
            ['country', 'region', 'city'].forEach(type => {
                document.getElementById(`node-${type}-btn`).classList.remove('active');
            });
            
            // Reset all nodes to original colors
            graph.forEachNode((node) => {
                const originalColor = originalNodeColors.get(node) || '#95a5a6';
                graph.setNodeAttribute(node, 'color', originalColor);
            });
            
            sigmaInstance.refresh();
        }
        
        function applyNodeGeographyColoring() {
            if (!nodeGeographyMode) {
                resetNodeColors();
                return;
            }
            
            // Reset all nodes to original color first
            graph.forEachNode((node) => {
                const originalColor = originalNodeColors.get(node) || '#95a5a6';
                graph.setNodeAttribute(node, 'color', originalColor);
            });
            
            // Collect unique geographic values
            const geoValues = new Set();
            const nodeGeoMap = new Map();
            
            graph.forEachEdge((edge, attributes) => {
                const [source, target] = graph.extremities(edge);
                let edgeGeoValues = [];
                
                if (nodeGeographyMode === 'country' && attributes.countries) {
                    edgeGeoValues = attributes.countries;
                } else if (nodeGeographyMode === 'region' && attributes.regions) {
                    edgeGeoValues = attributes.regions;
                } else if (nodeGeographyMode === 'city' && attributes.cities) {
                    edgeGeoValues = attributes.cities;
                }
                
                edgeGeoValues.forEach(geoValue => {
                    geoValues.add(geoValue);
                    
                    if (!nodeGeoMap.has(source)) nodeGeoMap.set(source, new Set());
                    if (!nodeGeoMap.has(target)) nodeGeoMap.set(target, new Set());
                    nodeGeoMap.get(source).add(geoValue);
                    nodeGeoMap.get(target).add(geoValue);
                });
            });
            
            // Assign colors to geographic values
            const geoValueColors = {};
            Array.from(geoValues).sort().forEach((value, index) => {
                geoValueColors[value] = diversePalette[index % diversePalette.length];
            });
            
            // Color nodes based on their primary geographic value
            nodeGeoMap.forEach((geoSet, nodeId) => {
                const primaryGeo = Array.from(geoSet)[0]; // Use first geo value for coloring
                if (primaryGeo && geoValueColors[primaryGeo]) {
                    graph.setNodeAttribute(nodeId, 'color', geoValueColors[primaryGeo]);
                }
            });
            
            sigmaInstance.refresh();
            updateLegend();
        }
        
        function clearAllFilters() {
            ['filter-competency', 'filter-technical_competency', 'filter-impact', 'filter-city', 'filter-country', 'filter-region', 'filter-cohort'].forEach(id => {
                document.getElementById(id).checked = false;
            });
            
            document.getElementById('weight-min').value = 1;
            document.getElementById('weight-max').value = 20;
            document.getElementById('search-nodes').value = '';
            document.getElementById('show-all-nodes').checked = true;
            
            activeFilters = {
                types: [],
                values: {},
                weightMin: 1,
                weightMax: 20,
                searchText: '',
                showAllNodes: true
            };
            
            updateFilters();
        }
        
        function updateFilters() {
            const weightMin = parseInt(document.getElementById('weight-min').value);
            const weightMax = parseInt(document.getElementById('weight-max').value);
            document.getElementById('weight-min-value').textContent = weightMin;
            document.getElementById('weight-max-value').textContent = weightMax;
            
            const typeFilters = [];
            ['competency', 'technical_competency', 'impact', 'city', 'country', 'region', 'cohort'].forEach(type => {
                if (document.getElementById(`filter-${type}`).checked) {
                    typeFilters.push(type);
                }
            });
            
            // Preserve the values object when updating filters
            const currentValues = activeFilters.values || {};
            
            activeFilters = {
                types: typeFilters,
                values: currentValues,
                weightMin: weightMin,
                weightMax: weightMax,
                searchText: document.getElementById('search-nodes').value.toLowerCase().trim(),
                showAllNodes: document.getElementById('show-all-nodes').checked
            };
            
            applyFilters();
        }
        
        function addAllToFilters(category, items) {
            // Map the categories to their corresponding filter keys in activeFilters.values
            const filterMappings = {
                'competencies': 'competency',
                'technical_competencies': 'technical_competency',
                'impacts': 'impact',
                'cities': 'city',
                'countries': 'country',
                'regions': 'region',
                'cohorts': 'cohort'
            };
            
            const filterKey = filterMappings[category];
            if (!filterKey) {
                console.warn('Unknown category:', category);
                return;
            }
            
            // Check the type checkbox to enable this filter type
            const typeCheckbox = document.getElementById(`filter-${filterKey}`);
            if (typeCheckbox && !typeCheckbox.checked) {
                typeCheckbox.checked = true;
                // Show the submenu
                const submenu = document.getElementById(`submenu-${filterKey}`);
                if (submenu) {
                    submenu.classList.add('active');
                }
            }
            
            // Initialize the filter array if it doesn't exist
            if (!activeFilters.values[filterKey]) {
                activeFilters.values[filterKey] = [];
            }
            
            // Add all items to the filter if they're not already there
            let addedCount = 0;
            items.forEach(item => {
                if (!activeFilters.values[filterKey].includes(item)) {
                    activeFilters.values[filterKey].push(item);
                    // Assign color to the new filter value
                    assignColorToValue(filterKey, item);
                    addedCount++;
                }
                
                // Check the corresponding checkbox in the UI
                const checkbox = document.querySelector(`input[type="checkbox"][data-type="${filterKey}"][data-value="${item}"]`);
                if (checkbox && !checkbox.checked) {
                    checkbox.checked = true;
                }
            });
            
            // Update the UI to show the new filters
            updateFilters();
            
            // Apply the filters
            applyFilters();
            
            // Provide feedback
            if (addedCount > 0) {
                console.log(`Added ${addedCount} ${category} to ${filterKey} filters:`, items);
                // You could add a visual feedback here like a toast notification
            } else {
                console.log(`All ${category} already in filters`);
            }
        }
        
        function applyFilters() {
            if (!graph || !sigmaInstance) return;
            
            // Show all nodes initially, but preserve geography colors if active
            graph.forEachNode((node) => {
                graph.setNodeAttribute(node, 'hidden', false);
                // Only reset node color if no geography mode is active
                if (!nodeGeographyMode) {
                    const originalColor = originalNodeColors.get(node) || '#95a5a6';
                    graph.setNodeAttribute(node, 'color', originalColor);
                }
            });
            
            graph.forEachEdge((edge) => {
                graph.setEdgeAttribute(edge, 'hidden', false);
                const originalColor = originalEdgeColors.get(edge) || '#bdc3c7';
                const originalSize = originalEdgeSizes.get(edge) || 1;
                graph.setEdgeAttribute(edge, 'color', originalColor);
                graph.setEdgeAttribute(edge, 'size', originalSize);
            });
            
            // Collect which types have active filters (values selected)
            const activeFilterTypes = [];
            for (const type of ['competency', 'technical_competency', 'impact', 'city', 'country', 'region', 'cohort']) {
                if (activeFilters.values[type] && activeFilters.values[type].length > 0) {
                    activeFilterTypes.push(type);
                }
            }
            
            // Apply edge type filters with faceted search logic
            // AND between categories (types), OR within each category
            if (activeFilterTypes.length > 0) {
                graph.forEachEdge((edge, attributes) => {
                    // Faceted search: edge must match at least one value from EACH active type
                    const shouldShow = activeFilterTypes.every(type => {
                        // Check if this edge has this type
                        if (!attributes[`is_${type}`]) return false;
                        
                        // Get edge values for this type
                        const edgeValues = attributes[`${type === 'competency' ? 'competencies' : 
                                                      type === 'technical_competency' ? 'technical_competencies' : 
                                                      type === 'impact' ? 'impacts' : 
                                                      type === 'city' ? 'cities' : 
                                                      type === 'country' ? 'countries' : 
                                                      type === 'region' ? 'regions' : 'cohorts'}`] || [];
                        
                        // Edge must match at least ONE selected value for this type (OR within)
                        return activeFilters.values[type].some(val => edgeValues.includes(val));
                    });
                    
                    graph.setEdgeAttribute(edge, 'hidden', !shouldShow);
                    
                    // Color edges based on filtered values
                    if (shouldShow) {
                        let assignedColor = null;
                        
                        // Color edges for any active filter type
                        for (const type of ['competency', 'technical_competency', 'impact', 'city', 'country', 'region', 'cohort']) {
                            if (activeFilters.values[type] && activeFilters.values[type].length > 0 && attributes[`is_${type}`]) {
                                const edgeValues = attributes[`${type === 'competency' ? 'competencies' : 
                                                              type === 'technical_competency' ? 'technical_competencies' : 
                                                              type === 'impact' ? 'impacts' : 
                                                              type === 'city' ? 'cities' : 
                                                              type === 'country' ? 'countries' : 
                                                              type === 'region' ? 'regions' : 'cohorts'}`] || [];
                                
                                // Find first matching value
                                for (const value of activeFilters.values[type]) {
                                    if (edgeValues.includes(value)) {
                                        assignedColor = valueColors[type][value];
                                        break;
                                    }
                                }
                                
                                if (assignedColor) break;
                            }
                        }
                        
                        if (assignedColor) {
                            graph.setEdgeAttribute(edge, 'color', assignedColor);
                        }
                    }
                });
            }
            
            // Apply weight filters
            graph.forEachEdge((edge, attributes) => {
                if (!attributes.hidden) {
                    const weight = attributes.weight || 1;
                    if (weight < activeFilters.weightMin || weight > activeFilters.weightMax) {
                        graph.setEdgeAttribute(edge, 'hidden', true);
                    }
                }
            });
            
            // Apply node search filter
            if (activeFilters.searchText) {
                graph.forEachNode((node, attributes) => {
                    if (!attributes.label?.toLowerCase().includes(activeFilters.searchText)) {
                        graph.setNodeAttribute(node, 'hidden', true);
                    }
                });
            }
            
            // Hide nodes with no visible edges (unless showAllNodes is checked)
            if (!activeFilters.showAllNodes && (activeFilters.types.length > 0 || activeFilters.weightMin > 1 || activeFilters.weightMax < 20)) {
                graph.forEachNode((node, attributes) => {
                    if (!attributes.hidden) {
                        const hasVisibleEdge = graph.edges(node).some(edge => 
                            !graph.getEdgeAttribute(edge, 'hidden')
                        );
                        if (!hasVisibleEdge) {
                            graph.setNodeAttribute(node, 'hidden', true);
                        }
                    }
                });
            }
            
            sigmaInstance.refresh();
            updateStats();
            updateLegend();
        }
        
        function updateStats() {
            if (!graph) return;
            
            let visibleNodes = 0;
            let visibleEdges = 0;
            
            graph.forEachNode((node, attributes) => {
                if (!attributes.hidden) visibleNodes++;
            });
            
            graph.forEachEdge((edge, attributes) => {
                if (!attributes.hidden) visibleEdges++;
            });
            
            const statsEl = document.getElementById('graph-stats');
            statsEl.innerHTML = `
                <strong>Network Stats:</strong><br>
                üìç Nodes: ${visibleNodes}/${graph.order}<br>
                üîó Edges: ${visibleEdges}/${graph.size}
            `;
        }
        
        // Start initialization when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>
